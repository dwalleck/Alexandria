Back before .NET Core 2.0 shipped, I wrote a [post](https://blogs.msdn.microsoft.com/dotnet/2017/06/07/performance-improvements-in-net-core/) highlighting various performance improvements in .NET Core 2.0 when compared with .NET Core 1.1 and the .NET Framework. As .NET Core 2.1 is in its final stages of being released, I thought it would be a good time to have some fun and take a tour through some of the myriad of performance improvements that have found their way into this release.

Performance improvements show up in .NET Core 2.1 in a variety of ways. One of the big focuses of the release has been on the new `System.Span<T>` type that, along with its friends like `System.Memory<T>`, are now at the heart of the runtime and core libraries (see [this MSDN Magazine article](https://msdn.microsoft.com/en-us/magazine/mt814808.aspx) for an introduction). New libraries have been added in this release, like [System.Memory.dll](https://github.com/dotnet/corefx/tree/master/src/System.Memory), [System.Threading.Channels.dll](https://github.com/dotnet/corefx/tree/master/src/System.Threading.Channels), and [System.IO.Pipelines.dll](https://github.com/dotnet/corefx/tree/master/src/System.IO.Pipelines), each targeted at specific scenarios. And many new members have been added to existing types, for example ~250 new members across existing types in the framework that accept or return the new span and memory types, and counting members on new types focusing on working with span and memory more than doubles that (e.g. the new `BinaryPrimitives` and `Utf8Formatter` types). All such improvements are worthy of their own focused blog posts, but they’re not what I’m focusing on here. Rather, I’m going to walk through some of the myriad of improvements that have been made to existing functionality, to existing types and methods, places where you upgrade a library or app from .NET Core 2.0 to 2.1 and performance just gets better. For the purposes of this post, I’m focused primarily on the [runtime](https://github.com/dotnet/coreclr) and the [core libraries](https://github.com/dotnet/corefx), but there have also been substantial performance improvements higher in the stack, as well as in tooling.

#### [](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1/#setup)Setup

In my post on [.NET Core 2.0 performance](https://blogs.msdn.microsoft.com/dotnet/2017/06/07/performance-improvements-in-net-core/), I demonstrated improvements using simple console apps with custom measurement loops, and I got feedback that readers would have preferred if it if I’d used a standard benchmarking tool. While I explicitly opted not to do so then (the reason being making it trivial for developers to follow along by copying and pasting code samples into their own console apps), this time around I decided to experiment with the approach, made easier by tooling improvements in the interim. So, to actually run the complete code samples shown in this post, you’ll need a few things. In my setup, I have both .NET Core 2.0 and a preview of .NET Core 2.1 installed. I then did `dotnet new console`, and modified the resulting .csproj as follows, which includes specifying both releases as target frameworks and including a package reference for [Benchmark.NET](https://www.nuget.org/packages/BenchmarkDotNet/), used to do the actual benchmarking.

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_BenchmarkDotNetCsProj.csproj"><tbody><tr><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-L1" data-line-number="1"></td><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-LC1">&lt;<span>Project</span> <span>Sdk</span>=<span><span>"</span>Microsoft.NET.Sdk<span>"</span></span>&gt;</td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-L2" data-line-number="2"></td><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-LC2"></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-L3" data-line-number="3"></td><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-LC3">&lt;<span>PropertyGroup</span>&gt;</td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-L4" data-line-number="4"></td><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-LC4">&lt;<span>AllowUnsafeBlocks</span>&gt;true&lt;/<span>AllowUnsafeBlocks</span>&gt;</td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-L5" data-line-number="5"></td><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-LC5">&lt;<span>OutputType</span>&gt;Exe&lt;/<span>OutputType</span>&gt;</td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-L6" data-line-number="6"></td><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-LC6">&lt;<span>TargetFrameworks</span>&gt;netcoreapp2.0;netcoreapp2.1&lt;/<span>TargetFrameworks</span>&gt;</td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-L7" data-line-number="7"></td><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-LC7">&lt;<span>Platforms</span>&gt;AnyCPU&lt;/<span>Platforms</span>&gt;</td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-L8" data-line-number="8"></td><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-LC8">&lt;/<span>PropertyGroup</span>&gt;</td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-L9" data-line-number="9"></td><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-LC9"></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-L10" data-line-number="10"></td><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-LC10">&lt;<span>ItemGroup</span>&gt;</td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-L11" data-line-number="11"></td><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-LC11">&lt;<span>PackageReference</span> <span>Include</span>=<span><span>"</span>BenchmarkDotNet<span>"</span></span> <span>Version</span>=<span><span>"</span>0.10.14<span>"</span></span> /&gt;</td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-L12" data-line-number="12"></td><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-LC12">&lt;/<span>ItemGroup</span>&gt;</td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-L13" data-line-number="13"></td><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-LC13"></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-L14" data-line-number="14"></td><td id="file-perfblog04162018_benchmarkdotnetcsproj-csproj-LC14">&lt;/<span>Project</span>&gt;</td></tr></tbody></table>

Then I have the following scaffolding code in my Program.cs:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_BenchmarkDotNetConfig.cs"><tbody><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC1"><span>using</span> <span>BenchmarkDotNet</span><span>.</span><span>Attributes</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC2"><span>using</span> <span>BenchmarkDotNet</span><span>.</span><span>Columns</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC3"><span>using</span> <span>BenchmarkDotNet</span><span>.</span><span>Configs</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC4"><span>using</span> <span>BenchmarkDotNet</span><span>.</span><span>Diagnosers</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L5" data-line-number="5"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC5"><span>using</span> <span>BenchmarkDotNet</span><span>.</span><span>Environments</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L6" data-line-number="6"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC6"><span>using</span> <span>BenchmarkDotNet</span><span>.</span><span>Exporters</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L7" data-line-number="7"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC7"><span>using</span> <span>BenchmarkDotNet</span><span>.</span><span>Jobs</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L8" data-line-number="8"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC8"><span>using</span> <span>BenchmarkDotNet</span><span>.</span><span>Loggers</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L9" data-line-number="9"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC9"><span>using</span> <span>BenchmarkDotNet</span><span>.</span><span>Order</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L10" data-line-number="10"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC10"><span>using</span> <span>BenchmarkDotNet</span><span>.</span><span>Reports</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L11" data-line-number="11"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC11"><span>using</span> <span>BenchmarkDotNet</span><span>.</span><span>Running</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L12" data-line-number="12"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC12"><span>using</span> <span>BenchmarkDotNet</span><span>.</span><span>Toolchains</span><span>.</span><span>CsProj</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L13" data-line-number="13"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC13"><span>using</span> <span>System</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L14" data-line-number="14"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC14"><span>using</span> <span>System</span><span>.</span><span>Collections</span><span>.</span><span>Generic</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L15" data-line-number="15"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC15"><span>using</span> <span>System</span><span>.</span><span>IO</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L16" data-line-number="16"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC16"><span>using</span> <span>System</span><span>.</span><span>Linq</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L17" data-line-number="17"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC17"><span>using</span> <span>System</span><span>.</span><span>Net</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L18" data-line-number="18"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC18"><span>using</span> <span>System</span><span>.</span><span>Net</span><span>.</span><span>Http</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L19" data-line-number="19"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC19"><span>using</span> <span>System</span><span>.</span><span>Net</span><span>.</span><span>Security</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L20" data-line-number="20"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC20"><span>using</span> <span>System</span><span>.</span><span>Net</span><span>.</span><span>Sockets</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L21" data-line-number="21"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC21"><span>using</span> <span>System</span><span>.</span><span>Numerics</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L22" data-line-number="22"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC22"><span>using</span> <span>System</span><span>.</span><span>Runtime</span><span>.</span><span>CompilerServices</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L23" data-line-number="23"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC23"><span>using</span> <span>System</span><span>.</span><span>Security</span><span>.</span><span>Authentication</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L24" data-line-number="24"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC24"><span>using</span> <span>System</span><span>.</span><span>Security</span><span>.</span><span>Cryptography</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L25" data-line-number="25"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC25"><span>using</span> <span>System</span><span>.</span><span>Security</span><span>.</span><span>Cryptography</span><span>.</span><span>X509Certificates</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L26" data-line-number="26"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC26"><span>using</span> <span>System</span><span>.</span><span>Text</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L27" data-line-number="27"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC27"><span>using</span> <span>System</span><span>.</span><span>Text</span><span>.</span><span>RegularExpressions</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L28" data-line-number="28"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC28"><span>using</span> <span>System</span><span>.</span><span>Threading</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L29" data-line-number="29"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC29"><span>using</span> <span>System</span><span>.</span><span>Threading</span><span>.</span><span>Tasks</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L30" data-line-number="30"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC30">#pragma warning disable <span>0618</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L31" data-line-number="31"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC31"></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L32" data-line-number="32"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC32"><span>public</span> <span>class</span> <span>MainConfig</span> <span>:</span> <span>ManualConfig</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L33" data-line-number="33"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC33"><span>{</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L34" data-line-number="34"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC34"><span>public</span> <span>MainConfig</span><span>(</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L35" data-line-number="35"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC35"><span>{</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L36" data-line-number="36"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC36"><span>Add</span><span>(</span><span>Job</span><span>.</span><span>Default</span><span>.</span><span>With</span><span>(</span><span>Platform</span><span>.</span><span>X64</span><span>)</span><span>.</span><span>With</span><span>(</span><span>CsProjCoreToolchain</span><span>.</span><span>NetCoreApp20</span><span>)</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L37" data-line-number="37"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC37"><span>Add</span><span>(</span><span>Job</span><span>.</span><span>Default</span><span>.</span><span>With</span><span>(</span><span>Platform</span><span>.</span><span>X64</span><span>)</span><span>.</span><span>With</span><span>(</span><span>CsProjCoreToolchain</span><span>.</span><span>NetCoreApp21</span><span>)</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L38" data-line-number="38"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC38"></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L39" data-line-number="39"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC39"><span>Add</span><span>(</span><span>MemoryDiagnoser</span><span>.</span><span>Default</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L40" data-line-number="40"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC40"><span>Add</span><span>(</span><span>new</span> <span>MinimalColumnProvider</span><span>(</span><span>)</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L41" data-line-number="41"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC41"><span>Add</span><span>(</span><span>MemoryDiagnoser</span><span>.</span><span>Default</span><span>.</span><span>GetColumnProvider</span><span>(</span><span>)</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L42" data-line-number="42"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC42"><span>Set</span><span>(</span><span>new</span> <span>DefaultOrderProvider</span><span>(</span><span>SummaryOrderPolicy</span><span>.</span><span>SlowestToFastest</span><span>)</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L43" data-line-number="43"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC43"><span>Add</span><span>(</span><span>MarkdownExporter</span><span>.</span><span>GitHub</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L44" data-line-number="44"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC44"><span>Add</span><span>(</span><span>new</span> <span>ConsoleLogger</span><span>(</span><span>)</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L45" data-line-number="45"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC45"><span>}</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L46" data-line-number="46"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC46"></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L47" data-line-number="47"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC47"><span>private</span> <span>sealed</span> <span>class</span> <span>MinimalColumnProvider</span> <span>:</span> <span>IColumnProvider</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L48" data-line-number="48"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC48"><span>{</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L49" data-line-number="49"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC49"><span>public</span> <span>IEnumerable</span><span>&lt;</span><span>IColumn</span><span>&gt;</span> <span>GetColumns</span><span>(</span><span>Summary</span> <span>summary</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L50" data-line-number="50"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC50"><span>{</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L51" data-line-number="51"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC51"><span>yield</span> <span>return</span> <span>TargetMethodColumn</span><span>.</span><span>Method</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L52" data-line-number="52"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC52"><span>yield</span> <span>return</span> <span>new</span> <span>JobCharacteristicColumn</span><span>(</span><span>InfrastructureMode</span><span>.</span><span>ToolchainCharacteristic</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L53" data-line-number="53"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC53"><span>yield</span> <span>return</span> <span>StatisticColumn</span><span>.</span><span>Mean</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L54" data-line-number="54"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC54"><span>}</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L55" data-line-number="55"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC55"><span>}</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L56" data-line-number="56"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC56"><span>}</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L57" data-line-number="57"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC57"></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L58" data-line-number="58"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC58"><span>public</span> <span>class</span> <span>Test</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L59" data-line-number="59"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC59"><span>{</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L60" data-line-number="60"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC60"><span>public</span> <span><span>static</span></span> <span>void</span> <span>Main</span><span>(</span><span>)</span> <span>=&gt;</span> <span>BenchmarkRunner</span><span>.</span><span>Run</span><span>&lt;</span><span>Test</span><span>&gt;</span><span>(</span><span>new</span> <span>MainConfig</span><span>(</span><span>)</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L61" data-line-number="61"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC61"></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L62" data-line-number="62"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC62"><span>// ... benchmarks go here</span></td></tr><tr><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-L63" data-line-number="63"></td><td id="file-perfblog04162018_benchmarkdotnetconfig-cs-LC63"><span>}</span></td></tr></tbody></table>

For each benchmark shown in this post, you should be able to simply copy-and-paste the relevant code to where commented in this .cs file, and then use `dotnet run -c Release -f netcoreapp2.0` to see the results. That will run the app using .NET Core 2.0, but the app itself is just the Benchmark.NET host, and the Benchmark.NET library will in turn create, build, and run .NET Core 2.0 and 2.1 apps for comparison. Note that in each results section, I’ve removed superfluous columns, to keep things tidy. I’ve also generally only shown results from running on Windows, when there’s no meaningful difference to highlight between platforms.

With that, let’s explore.

## [](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1/#jit)JIT

A lot of work has gone into improving the Just-In-Time (JIT) compiler in .NET Core 2.1, with many optimizations that enhance a wide-range of libraries and applications. Many of these improvements were sought based on needs of the core libraries themselves, giving these improvements both targeted and broad impact.

Let’s start with an example of a JIT improvement that can have broad impact across many types, but in particular for collection classes. .NET Core 2.1 has improvements around “devirtualization”, where the JIT is able to statically determine the target of some virtual invocations and as a result avoid virtual dispatch costs and enable potential inlining. In particular, PR [dotnet/coreclr#14125](https://github.com/dotnet/coreclr/pull/14125) taught the JIT about the `EqualityComparer<T>.Default` member, extending the JIT’s intrinsic recognizer to recognize this getter. When a method then does `EqualityComparer<T>.Default.Equals`, for example, the JIT is able to both devirtualize and often inline the callee, which for certain `T` types makes a huge difference in throughput. Before this improvment, if `T` were `Int32`, the JIT would end up emitting code to make a virtual call to the underlying `GenericEqualityComparer<T>.Equals` method, but with this change, the JIT is able to inline what ends up being a call to `Int32.Equals`, which itself is inlineable, and `EqualityComparer<int>.Default.Equals` becomes as efficient as directly comparing two `Int32`s for equality. The impact of this is obvious with the following benchmark:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_EqualityComparerInt32.cs"><tbody><tr><td id="file-perfblog04162018_equalitycomparerint32-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_equalitycomparerint32-cs-LC1"><span>private</span> <span><span>static</span></span> <span>int</span><span>[</span><span>]</span> <span>s_intArray</span> <span>=</span> <span>Enumerable</span><span>.</span><span>Range</span><span>(</span><span>0</span><span>,</span> <span>100_000_000</span><span>)</span><span>.</span><span>ToArray</span><span>(</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_equalitycomparerint32-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_equalitycomparerint32-cs-LC2"></td></tr><tr><td id="file-perfblog04162018_equalitycomparerint32-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_equalitycomparerint32-cs-LC3"><span>[</span><span>Benchmark</span><span>(</span><span>OperationsPerInvoke</span> <span>=</span> <span>100_000_000</span><span>)</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_equalitycomparerint32-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_equalitycomparerint32-cs-LC4"><span>public</span> <span>int</span> <span>EqualityComparerInt32</span><span>(</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_equalitycomparerint32-cs-L5" data-line-number="5"></td><td id="file-perfblog04162018_equalitycomparerint32-cs-LC5"><span>{</span></td></tr><tr><td id="file-perfblog04162018_equalitycomparerint32-cs-L6" data-line-number="6"></td><td id="file-perfblog04162018_equalitycomparerint32-cs-LC6"><span>int</span><span>[</span><span>]</span> <span>items</span> <span>=</span> <span>s_intArray</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_equalitycomparerint32-cs-L7" data-line-number="7"></td><td id="file-perfblog04162018_equalitycomparerint32-cs-LC7"></td></tr><tr><td id="file-perfblog04162018_equalitycomparerint32-cs-L8" data-line-number="8"></td><td id="file-perfblog04162018_equalitycomparerint32-cs-LC8"><span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>items</span><span>.</span><span>Length</span><span>;</span> <span>i</span><span>++</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_equalitycomparerint32-cs-L9" data-line-number="9"></td><td id="file-perfblog04162018_equalitycomparerint32-cs-LC9"><span>if</span> <span>(</span><span>EqualityComparer</span><span>&lt;</span><span>int</span><span>&gt;</span><span>.</span><span>Default</span><span>.</span><span>Equals</span><span>(</span><span>items</span><span>[</span><span>i</span><span>]</span><span>,</span> <span>-</span><span>1</span><span>)</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_equalitycomparerint32-cs-L10" data-line-number="10"></td><td id="file-perfblog04162018_equalitycomparerint32-cs-LC10"><span>return</span> <span>i</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_equalitycomparerint32-cs-L11" data-line-number="11"></td><td id="file-perfblog04162018_equalitycomparerint32-cs-LC11"></td></tr><tr><td id="file-perfblog04162018_equalitycomparerint32-cs-L12" data-line-number="12"></td><td id="file-perfblog04162018_equalitycomparerint32-cs-LC12"><span>return</span> <span>-</span><span>1</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_equalitycomparerint32-cs-L13" data-line-number="13"></td><td id="file-perfblog04162018_equalitycomparerint32-cs-LC13"><span>}</span></td></tr></tbody></table>

On my machine, I get output like the following, showcasing an ~2.5x speedup over .NET Core 2.0:

| Method | Toolchain | Mean |
| --- | --- | --- |
| EqualityComparerInt32 | .NET Core 2.0 | 2.2106 ns |
| EqualityComparerInt32 | .NET Core 2.1 | 0.8725 ns |

Such improvements show up in indirect usage of `EqualityComparer<T>.Default`, as well. Many of the collection types in .NET, including `Dictionary<TKey, TValue>`, utilize `EqualityComparer<T>.Default`, and we can see the impact this improvement has on various operations employed by such collections. For example, PR [dotnet/coreclr#15419](https://github.com/dotnet/coreclr/pull/15419) from [@benaadams](https://github.com/benaadams) tweaked `Dictionary<TKey, TValue>`‘s `ContainsValue` implementation to better take advantage of this devirtualization and inlining, such that running this benchmark:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_DictionaryContainsValue.cs"><tbody><tr><td id="file-perfblog04162018_dictionarycontainsvalue-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_dictionarycontainsvalue-cs-LC1"><span>private</span> <span>const</span> <span>int</span> <span>Items</span> <span>=</span> <span>3_000</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_dictionarycontainsvalue-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_dictionarycontainsvalue-cs-LC2"><span>private</span> <span><span>static</span></span> <span>readonly</span> <span>Dictionary</span><span>&lt;</span><span>int</span><span>,</span> <span>int</span><span>&gt;</span> <span>s_dict</span> <span>=</span> <span>Enumerable</span><span>.</span><span>Range</span><span>(</span><span>0</span><span>,</span> <span>Items</span><span>)</span><span>.</span><span>ToDictionary</span><span>(</span>i <span>=&gt;</span> <span>i</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_dictionarycontainsvalue-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_dictionarycontainsvalue-cs-LC3"></td></tr><tr><td id="file-perfblog04162018_dictionarycontainsvalue-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_dictionarycontainsvalue-cs-LC4"><span>[</span><span>Benchmark</span><span>(</span><span>OperationsPerInvoke</span> <span>=</span> <span>Items</span><span>)</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_dictionarycontainsvalue-cs-L5" data-line-number="5"></td><td id="file-perfblog04162018_dictionarycontainsvalue-cs-LC5"><span>public</span> <span>int</span> <span>DictionaryContainsValue</span><span>(</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_dictionarycontainsvalue-cs-L6" data-line-number="6"></td><td id="file-perfblog04162018_dictionarycontainsvalue-cs-LC6"><span>{</span></td></tr><tr><td id="file-perfblog04162018_dictionarycontainsvalue-cs-L7" data-line-number="7"></td><td id="file-perfblog04162018_dictionarycontainsvalue-cs-LC7"><span>Dictionary</span><span>&lt;</span><span>int</span><span>,</span> <span>int</span><span>&gt;</span> <span>d</span> <span>=</span> <span>s_dict</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_dictionarycontainsvalue-cs-L8" data-line-number="8"></td><td id="file-perfblog04162018_dictionarycontainsvalue-cs-LC8"><span>int</span> <span>count</span> <span>=</span> <span>0</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_dictionarycontainsvalue-cs-L9" data-line-number="9"></td><td id="file-perfblog04162018_dictionarycontainsvalue-cs-LC9"></td></tr><tr><td id="file-perfblog04162018_dictionarycontainsvalue-cs-L10" data-line-number="10"></td><td id="file-perfblog04162018_dictionarycontainsvalue-cs-LC10"><span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>Items</span><span>;</span> <span>i</span><span>++</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_dictionarycontainsvalue-cs-L11" data-line-number="11"></td><td id="file-perfblog04162018_dictionarycontainsvalue-cs-LC11"><span>if</span> <span>(</span><span>d</span><span>.</span><span>ContainsValue</span><span>(</span><span>i</span><span>)</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_dictionarycontainsvalue-cs-L12" data-line-number="12"></td><td id="file-perfblog04162018_dictionarycontainsvalue-cs-LC12"><span>count</span><span>++</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_dictionarycontainsvalue-cs-L13" data-line-number="13"></td><td id="file-perfblog04162018_dictionarycontainsvalue-cs-LC13"></td></tr><tr><td id="file-perfblog04162018_dictionarycontainsvalue-cs-L14" data-line-number="14"></td><td id="file-perfblog04162018_dictionarycontainsvalue-cs-LC14"><span>return</span> <span>count</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_dictionarycontainsvalue-cs-L15" data-line-number="15"></td><td id="file-perfblog04162018_dictionarycontainsvalue-cs-LC15"><span>}</span></td></tr></tbody></table>

produces on my machine results like the following, showcasing an ~2.25x speedup:

| Method | Toolchain | Mean |
| --- | --- | --- |
| DictionaryContainsValue | .NET Core 2.0 | 3.419 us |
| DictionaryContainsValue | .NET Core 2.1 | 1.519 us |

In many situations, improvements like this in the JIT implicitly show up as improvements in higher-level code. In this specific, case, though, it required the aforementioned change, which updated code like:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_OldDictionaryEqualityComparer.cs"><tbody><tr><td id="file-perfblog04162018_olddictionaryequalitycomparer-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_olddictionaryequalitycomparer-cs-LC1"><span>EqualityComparer</span><span>&lt;</span><span>TValue</span><span>&gt;</span> <span>c</span> <span>=</span> <span>EqualityComparer</span><span>&lt;</span><span>TValue</span><span>&gt;</span><span>.</span><span>Default</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_olddictionaryequalitycomparer-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_olddictionaryequalitycomparer-cs-LC2"><span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>_count</span><span>;</span> <span>i</span><span>++</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_olddictionaryequalitycomparer-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_olddictionaryequalitycomparer-cs-LC3"><span>if</span> <span>(</span><span>_entries</span><span>[</span><span>i</span><span>]</span><span>.</span><span>hashCode</span> <span>&gt;=</span> <span>0</span> <span>&amp;&amp;</span> <span>c</span><span>.</span><span>Equals</span><span>(</span><span>_entries</span><span>[</span><span>i</span><span>]</span><span>.</span><span>value</span><span>,</span> <span>value</span><span>)</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_olddictionaryequalitycomparer-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_olddictionaryequalitycomparer-cs-LC4"><span>return</span> <span>true</span><span>;</span></td></tr></tbody></table>

to instead be like:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_NewDictionaryEqualityComparer.cs"><tbody><tr><td id="file-perfblog04162018_newdictionaryequalitycomparer-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_newdictionaryequalitycomparer-cs-LC1"><span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>_count</span><span>;</span> <span>i</span><span>++</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_newdictionaryequalitycomparer-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_newdictionaryequalitycomparer-cs-LC2"><span>if</span> <span>(</span><span>_entries</span><span>[</span><span>i</span><span>]</span><span>.</span><span>hashCode</span> <span>&gt;=</span> <span>0</span> <span>&amp;&amp;</span> <span>EqualityComparer</span><span>&lt;</span><span>TValue</span><span>&gt;</span><span>.</span><span>Default</span><span>.</span><span>Equals</span><span>(</span><span>_entries</span><span>[</span><span>i</span><span>]</span><span>.</span><span>value</span><span>,</span> <span>value</span><span>)</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_newdictionaryequalitycomparer-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_newdictionaryequalitycomparer-cs-LC3"><span>return</span> <span>true</span><span>;</span></td></tr></tbody></table>

In other words, previously this code had been optimized to avoid the overheads associated with using `EqualityComparer<TValue>.Default` on each iteration of the loop. But that micro-optimization then defeated the JIT’s devirtualization logic, such that what used to be an optimization is now a deoptimization, and the code had to be changed back to a pattern the JIT could recognize to make it as efficient as possible. A similar change was made in PR [dotnet/corefx#25097](https://github.com/dotnet/corefx/pull/25097), in order to benefit from this improvement in LINQ’s Enumerable.Contains. However, there are many places where this JIT improvement does simply improve existing code, without any required changes. (There are also places where there are known further improvements to be made, e.g. [dotnet/coreclr#17273](https://github.com/dotnet/coreclr/issues/17273).)

In the previous discussion, I mentioned “intrinsics” and the ability for the JIT to recognize and special-case certain methods in order to help it better optimize for specific uses. .NET Core 2.1 sees additional intrinsic work, including for some long-standing but rather poor performing methods in .NET. A key example is [`Enum.HasFlag`](https://docs.microsoft.com/en-us/dotnet/api/system.enum.hasflag). This method should be simple, just doing a bit flag test to see whether a given enum value contains another, but because of how this API is defined, it’s relatively expensive to use. No more. In .NET Core 2.1 `Enum.HasFlag` is now a JIT intrinsic, such that the JIT generates the same quality code you would write by hand if you were doing manual bit flag testing. The evidence of this is in a simple benchmark:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_EnumHasFlag.cs"><tbody><tr><td id="file-perfblog04162018_enumhasflag-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_enumhasflag-cs-LC1"><span>[</span><span>Benchmark</span><span>(</span><span>OperationsPerInvoke</span> <span>=</span> <span>10_000</span><span>)</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_enumhasflag-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_enumhasflag-cs-LC2"><span>public</span> <span>bool</span> <span>EnumHasFlag</span><span>(</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_enumhasflag-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_enumhasflag-cs-LC3"><span>{</span></td></tr><tr><td id="file-perfblog04162018_enumhasflag-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_enumhasflag-cs-LC4"><span>FileAccess</span> <span>value</span> <span>=</span> <span>FileAccess</span><span>.</span><span>ReadWrite</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_enumhasflag-cs-L5" data-line-number="5"></td><td id="file-perfblog04162018_enumhasflag-cs-LC5"><span>bool</span> <span>result</span> <span>=</span> <span>true</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_enumhasflag-cs-L6" data-line-number="6"></td><td id="file-perfblog04162018_enumhasflag-cs-LC6"></td></tr><tr><td id="file-perfblog04162018_enumhasflag-cs-L7" data-line-number="7"></td><td id="file-perfblog04162018_enumhasflag-cs-LC7"><span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>10_000</span><span>;</span> <span>i</span><span>++</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_enumhasflag-cs-L8" data-line-number="8"></td><td id="file-perfblog04162018_enumhasflag-cs-LC8"><span>{</span></td></tr><tr><td id="file-perfblog04162018_enumhasflag-cs-L9" data-line-number="9"></td><td id="file-perfblog04162018_enumhasflag-cs-LC9"><span>result</span> <span>&amp;=</span> <span>value</span><span>.</span><span>HasFlag</span><span>(</span><span>FileAccess</span><span>.</span><span>Read</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_enumhasflag-cs-L10" data-line-number="10"></td><td id="file-perfblog04162018_enumhasflag-cs-LC10"><span>}</span></td></tr><tr><td id="file-perfblog04162018_enumhasflag-cs-L11" data-line-number="11"></td><td id="file-perfblog04162018_enumhasflag-cs-LC11"></td></tr><tr><td id="file-perfblog04162018_enumhasflag-cs-L12" data-line-number="12"></td><td id="file-perfblog04162018_enumhasflag-cs-LC12"><span>return</span> <span>result</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_enumhasflag-cs-L13" data-line-number="13"></td><td id="file-perfblog04162018_enumhasflag-cs-LC13"><span>}</span></td></tr></tbody></table>

On this test, I get results like the following, showing a 100% reduction in allocation (from 48 bytes per call to 0 bytes per call) and an ~50x improvement in throughput:

| Method | Toolchain | Mean | Allocated |
| --- | --- | --- | --- |
| EnumHasFlag | .NET Core 2.0 | 14.9214 ns | 48 B |
| EnumHasFlag | .NET Core 2.1 | 0.2932 ns | 0 B |

This is an example where developers that cared about performance had to avoid writing code a certain way and can now write code that’s both maintainable and efficient, and also helps unaware developers fall into a “pit of success”. (Incidentally, this is also a case where Mono already [had this optimization](http://www.mono-project.com/docs/about-mono/releases/4.0.0/).)

Another example of this isn’t specific to a given API, but rather applies to the general shape of code. Consider the following implementation of string equality:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_LoopBodyLayout.cs"><tbody><tr><td id="file-perfblog04162018_loopbodylayout-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC1"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC2"><span>public</span> <span>bool</span> <span>LoopBodyLayout</span><span>(</span><span>)</span> <span>=&gt;</span> <span>StringsAreEqual</span><span>(</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC3"><span>"this is a test to see if these strings are equal"</span><span>,</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC4"><span>"this is a test to see if these strings are equal"</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L5" data-line-number="5"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC5"></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L6" data-line-number="6"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC6"><span>private</span> <span>unsafe</span> <span>bool</span> <span>StringsAreEqual</span><span>(</span><span>string</span> <span>strA</span><span>,</span> <span>string</span> <span>strB</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L7" data-line-number="7"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC7"><span>{</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L8" data-line-number="8"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC8"><span>int</span> <span>length</span> <span>=</span> <span>strA</span><span>.</span><span>Length</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L9" data-line-number="9"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC9"></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L10" data-line-number="10"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC10">fixed <span>(</span><span>char</span><span>*</span> <span>ap</span> <span>=</span> <span>strA</span><span>,</span> <span>bp</span> <span>=</span> <span>strB</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L11" data-line-number="11"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC11"><span>{</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L12" data-line-number="12"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC12"><span>char</span><span>*</span> <span>a</span> <span>=</span> <span>ap</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L13" data-line-number="13"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC13"><span>char</span><span>*</span> <span>b</span> <span>=</span> <span>bp</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L14" data-line-number="14"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC14"></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L15" data-line-number="15"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC15"><span>while</span> <span>(</span><span>length</span> <span>!=</span> <span>0</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L16" data-line-number="16"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC16"><span>{</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L17" data-line-number="17"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC17"><span>int</span> <span>charA</span> <span>=</span> <span>*</span><span>a</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L18" data-line-number="18"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC18"><span>int</span> <span>charB</span> <span>=</span> <span>*</span><span>b</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L19" data-line-number="19"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC19"></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L20" data-line-number="20"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC20"><span>if</span> <span>(</span><span>charA</span> <span>!=</span> <span>charB</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L21" data-line-number="21"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC21"><span>{</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L22" data-line-number="22"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC22"><span>return</span> <span>false</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L23" data-line-number="23"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC23"><span>}</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L24" data-line-number="24"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC24"></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L25" data-line-number="25"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC25"><span>a</span><span>++</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L26" data-line-number="26"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC26"><span>b</span><span>++</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L27" data-line-number="27"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC27"><span>length</span><span>--</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L28" data-line-number="28"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC28"><span>}</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L29" data-line-number="29"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC29"></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L30" data-line-number="30"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC30"><span>return</span> <span>true</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L31" data-line-number="31"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC31"><span>}</span></td></tr><tr><td id="file-perfblog04162018_loopbodylayout-cs-L32" data-line-number="32"></td><td id="file-perfblog04162018_loopbodylayout-cs-LC32"><span>}</span></td></tr></tbody></table>

Unfortunately, on previous releases of .NET, the code generated here was suboptimal, in particular due to the early exit from within the loop. Developers that cared about performance had to write this kind of loop in a specialized way, using `goto`s, for example as seen in the .NET Core 2.0 implementation of `String`‘s [CompareOrdinalIgnoreCaseHelper method](https://github.com/dotnet/coreclr/blob/2e651d0b3eb5593f69d91c77b9d91556dccddf51/src/mscorlib/src/System/String.Comparison.cs#L21). In .NET Core 2.1, PR [dotnet/coreclr#13314](https://github.com/dotnet/coreclr/pull/13314) rearranges basic blocks in loops to avoid needing such workarounds. You can see in .NET Core 2.1 that `goto` in CompareOrdinalIgnoreCaseHelper is [now gone](https://github.com/dotnet/coreclr/blob/b3dff4d441013cbfa39ce209f45ba96d605d8e77/src/mscorlib/shared/System/String.Comparison.cs#L47), and the shown benchmark is almost double the throughput of what it was in the previous release:

| Method | Toolchain | Mean |
| --- | --- | --- |
| LoopBodyLayout | .NET Core 2.0 | 56.30 ns |
| LoopBodyLayout | .NET Core 2.1 | 30.49 ns |

Of course, folks contributing to the JIT don’t just care about such macro-level enhancements to the JIT, but also to improvements as low-level as tuning what instructions are generated for specific operations. For example, PR [dotnet/coreclr#13626](https://github.com/dotnet/coreclr/pull/13626) from [@mikedn](https://github.com/mikedn) enables the JIT to generate the more efficient BT instruction in some situations where TEST and LSH were otherwise being used. The impact of that can be seen on this benchmark extracted from that PR’s comments:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_LoweringTESTtoBT.cs"><tbody><tr><td id="file-perfblog04162018_loweringtesttobt-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_loweringtesttobt-cs-LC1"><span>[</span><span>Benchmark</span><span>(</span><span>OperationsPerInvoke</span> <span>=</span> <span>10_000_000</span><span>)</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_loweringtesttobt-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_loweringtesttobt-cs-LC2"><span>public</span> <span>int</span> <span>LoweringTESTtoBT</span><span>(</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_loweringtesttobt-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_loweringtesttobt-cs-LC3"><span>{</span></td></tr><tr><td id="file-perfblog04162018_loweringtesttobt-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_loweringtesttobt-cs-LC4"><span>int</span> <span>y</span> <span>=</span> <span>0</span><span>,</span> <span>x</span> <span>=</span> <span>0</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_loweringtesttobt-cs-L5" data-line-number="5"></td><td id="file-perfblog04162018_loweringtesttobt-cs-LC5"></td></tr><tr><td id="file-perfblog04162018_loweringtesttobt-cs-L6" data-line-number="6"></td><td id="file-perfblog04162018_loweringtesttobt-cs-LC6"><span>while</span> <span>(</span><span>x</span><span>++</span> <span>&lt;</span> <span>10_000_000</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_loweringtesttobt-cs-L7" data-line-number="7"></td><td id="file-perfblog04162018_loweringtesttobt-cs-LC7"><span>if</span> <span>(</span><span>(</span><span>x</span> <span>&amp;</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>y</span><span>)</span><span>)</span> <span>==</span> <span>0</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_loweringtesttobt-cs-L8" data-line-number="8"></td><td id="file-perfblog04162018_loweringtesttobt-cs-LC8"><span>y</span><span>++</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_loweringtesttobt-cs-L9" data-line-number="9"></td><td id="file-perfblog04162018_loweringtesttobt-cs-LC9"></td></tr><tr><td id="file-perfblog04162018_loweringtesttobt-cs-L10" data-line-number="10"></td><td id="file-perfblog04162018_loweringtesttobt-cs-LC10"><span>return</span> <span>y</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_loweringtesttobt-cs-L11" data-line-number="11"></td><td id="file-perfblog04162018_loweringtesttobt-cs-LC11"><span>}</span></td></tr></tbody></table>

where with this change, .NET Core 2.1 executes this benchmark 40% faster than it did in .NET Core 2.0:

| Method | Toolchain | Mean |
| --- | --- | --- |
| LoweringTESTtoBT | .NET Core 2.0 | 1.414 ns |
| LoweringTESTtoBT | .NET Core 2.1 | 1.057 ns |

The JIT also saw a variety of improvements in .NET Core 2.1 around boxing. One of my personal favorites (because of the impact it has on async methods, to be discussed later in this post) is PR [dotnet/coreclr#14698](https://github.com/dotnet/coreclr/pull/14698) (and a follow-up PR [dotnet/coreclr#17006](https://github.com/dotnet/coreclr/pull/17006)), which enables writing code that would have previously allocated and now doesn’t. Consider this benchmark:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_BoxingAllocations.cs"><tbody><tr><td id="file-perfblog04162018_boxingallocations-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_boxingallocations-cs-LC1"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_boxingallocations-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_boxingallocations-cs-LC2"><span>public</span> <span>void</span> <span>BoxingAllocations</span><span>(</span><span>)</span> <span>=&gt;</span> <span>BoxingAllocations</span><span>(</span><span>default</span><span>(</span><span>Dog</span><span>)</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_boxingallocations-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_boxingallocations-cs-LC3"></td></tr><tr><td id="file-perfblog04162018_boxingallocations-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_boxingallocations-cs-LC4"><span>private</span> <span>void</span> <span>BoxingAllocations</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>T</span> <span>thing</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_boxingallocations-cs-L5" data-line-number="5"></td><td id="file-perfblog04162018_boxingallocations-cs-LC5"><span>{</span></td></tr><tr><td id="file-perfblog04162018_boxingallocations-cs-L6" data-line-number="6"></td><td id="file-perfblog04162018_boxingallocations-cs-LC6"><span>if</span> <span>(</span><span>thing</span> <span>is</span> <span>IAnimal</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_boxingallocations-cs-L7" data-line-number="7"></td><td id="file-perfblog04162018_boxingallocations-cs-LC7"><span>(</span><span>(</span><span>IAnimal</span><span>)</span><span>thing</span><span>)</span><span>.</span><span>MakeSound</span><span>(</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_boxingallocations-cs-L8" data-line-number="8"></td><td id="file-perfblog04162018_boxingallocations-cs-LC8"><span>}</span></td></tr><tr><td id="file-perfblog04162018_boxingallocations-cs-L9" data-line-number="9"></td><td id="file-perfblog04162018_boxingallocations-cs-LC9"></td></tr><tr><td id="file-perfblog04162018_boxingallocations-cs-L10" data-line-number="10"></td><td id="file-perfblog04162018_boxingallocations-cs-LC10"><span>private</span> <span>struct</span> <span>Dog</span> <span>:</span> <span>IAnimal</span></td></tr><tr><td id="file-perfblog04162018_boxingallocations-cs-L11" data-line-number="11"></td><td id="file-perfblog04162018_boxingallocations-cs-LC11"><span>{</span></td></tr><tr><td id="file-perfblog04162018_boxingallocations-cs-L12" data-line-number="12"></td><td id="file-perfblog04162018_boxingallocations-cs-LC12"><span>public</span> <span>void</span> <span>Bark</span><span>(</span><span>)</span> <span>{</span> <span>}</span></td></tr><tr><td id="file-perfblog04162018_boxingallocations-cs-L13" data-line-number="13"></td><td id="file-perfblog04162018_boxingallocations-cs-LC13"><span>void</span> <span>IAnimal</span><span>.</span><span>MakeSound</span><span>(</span><span>)</span> <span>=&gt;</span> <span>Bark</span><span>(</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_boxingallocations-cs-L14" data-line-number="14"></td><td id="file-perfblog04162018_boxingallocations-cs-LC14"><span>}</span></td></tr><tr><td id="file-perfblog04162018_boxingallocations-cs-L15" data-line-number="15"></td><td id="file-perfblog04162018_boxingallocations-cs-LC15"></td></tr><tr><td id="file-perfblog04162018_boxingallocations-cs-L16" data-line-number="16"></td><td id="file-perfblog04162018_boxingallocations-cs-LC16"><span>private</span> <span>interface</span> <span>IAnimal</span></td></tr><tr><td id="file-perfblog04162018_boxingallocations-cs-L17" data-line-number="17"></td><td id="file-perfblog04162018_boxingallocations-cs-LC17"><span>{</span></td></tr><tr><td id="file-perfblog04162018_boxingallocations-cs-L18" data-line-number="18"></td><td id="file-perfblog04162018_boxingallocations-cs-LC18"><span>void</span> <span>MakeSound</span><span>(</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_boxingallocations-cs-L19" data-line-number="19"></td><td id="file-perfblog04162018_boxingallocations-cs-LC19"><span>}</span></td></tr></tbody></table>

In it, we’ve got an `IAnimal` with a `MakeSound` method, and we’ve got a method that wants to accept an arbitrary `T`, test to see whether it’s an `IAnimal` (it might be something else), and if it is, call its `MakeSound` method. Prior to .NET Core 2.1, this allocates, because in order to get the `T` as an `IAnimal` on which I can call `MakeSound`, the `T` needs to be cast to the interface, which for a value type results in it being boxed, and therefore allocates. In .NET Core 2.1, though, this pattern is recognized, and the JIT is able not only to undo the boxing, but also then devirtualize and inline the callee. The impact of this can be substantial when this kind of pattern shows up on hot paths. Here are the benchmark results, highlighting a significant improvement in throughput and an elimination of the boxing allocations:

| Method | Toolchain | Mean | Allocated |
| --- | --- | --- | --- |
| BoxingAllocations | .NET Core 2.0 | 12.444 ns | 48 B |
| BoxingAllocations | .NET Core 2.1 | 1.391 ns | 0 B |

This highlights just some of the improvements that have gone into the JIT in .NET Core 2.1. And while each is impressive in its own right, the whole is greater than the sum of the parts, as work was done to ensure that all of these optimizations, from devirtualization, to boxing removal, to invocation of the unboxed entry, to inlining, to struct promotion, to copy prop through promoted fields, to cleaning up after unused struct locals, and so on, all play nicely together. Consider this example provided by [@AndyAyersMS](https://github.com/andyayersms):

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_JitOverallExample.cs"><tbody><tr><td id="file-perfblog04162018_jitoverallexample-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_jitoverallexample-cs-LC1"><span>using</span> <span>System</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_jitoverallexample-cs-LC2"></td></tr><tr><td id="file-perfblog04162018_jitoverallexample-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_jitoverallexample-cs-LC3"><span>class</span> <span>Y</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_jitoverallexample-cs-LC4"><span>{</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample-cs-L5" data-line-number="5"></td><td id="file-perfblog04162018_jitoverallexample-cs-LC5"><span><span>static</span></span> <span>int</span> <span>Main</span><span>(</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample-cs-L6" data-line-number="6"></td><td id="file-perfblog04162018_jitoverallexample-cs-LC6"><span>{</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample-cs-L7" data-line-number="7"></td><td id="file-perfblog04162018_jitoverallexample-cs-LC7"><span>var</span> <span>s</span> <span>=</span> <span>new</span> <span>X</span><span>&lt;</span><span>string</span><span>&gt;</span><span>(</span><span>"hello, world!"</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample-cs-L8" data-line-number="8"></td><td id="file-perfblog04162018_jitoverallexample-cs-LC8"><span>(</span><span>(</span><span>IPrint</span><span>)</span><span>s</span><span>)</span><span>.</span><span>Print</span><span>(</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample-cs-L9" data-line-number="9"></td><td id="file-perfblog04162018_jitoverallexample-cs-LC9"><span>return</span> <span>100</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample-cs-L10" data-line-number="10"></td><td id="file-perfblog04162018_jitoverallexample-cs-LC10"><span>}</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample-cs-L11" data-line-number="11"></td><td id="file-perfblog04162018_jitoverallexample-cs-LC11"><span>}</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample-cs-L12" data-line-number="12"></td><td id="file-perfblog04162018_jitoverallexample-cs-LC12"></td></tr><tr><td id="file-perfblog04162018_jitoverallexample-cs-L13" data-line-number="13"></td><td id="file-perfblog04162018_jitoverallexample-cs-LC13"><span>interface</span> <span>IPrint</span> <span>{</span> <span>void</span> <span>Print</span><span>(</span><span>)</span><span>;</span> <span>}</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample-cs-L14" data-line-number="14"></td><td id="file-perfblog04162018_jitoverallexample-cs-LC14"></td></tr><tr><td id="file-perfblog04162018_jitoverallexample-cs-L15" data-line-number="15"></td><td id="file-perfblog04162018_jitoverallexample-cs-LC15"><span>struct</span> <span>X</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>:</span> <span>IPrint</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample-cs-L16" data-line-number="16"></td><td id="file-perfblog04162018_jitoverallexample-cs-LC16"><span>{</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample-cs-L17" data-line-number="17"></td><td id="file-perfblog04162018_jitoverallexample-cs-LC17"><span>T</span> <span>_t</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample-cs-L18" data-line-number="18"></td><td id="file-perfblog04162018_jitoverallexample-cs-LC18"><span>public</span> <span>X</span><span>(</span><span>T</span> <span>t</span><span>)</span> <span>=&gt;</span> <span>_t</span> <span>=</span> <span>t</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample-cs-L19" data-line-number="19"></td><td id="file-perfblog04162018_jitoverallexample-cs-LC19"><span>public</span> <span>void</span> <span>Print</span><span>(</span><span>)</span> <span>=&gt;</span> <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>_t</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample-cs-L20" data-line-number="20"></td><td id="file-perfblog04162018_jitoverallexample-cs-LC20"><span>}</span></td></tr></tbody></table>

In .NET Core 2.0, this resulted in the following assembly code generated:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_JitOverallExample_20.asm"><tbody><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L1" data-line-number="1"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC1"><span>// Main method...</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L2" data-line-number="2"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC2"><span>push</span><span> </span><span>ebp</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L3" data-line-number="3"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC3"><span>mov</span><span> </span><span>ebp</span><span>,</span><span> </span><span>esp</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L4" data-line-number="4"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC4"><span>push</span><span> </span><span>esi</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L5" data-line-number="5"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC5"><span>mov</span><span> </span><span>esi</span><span>,</span><span> gword ptr </span><span>[</span><span>0875203CH</span><span>]</span><span> </span><span>'hello, world!'</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L6" data-line-number="6"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC6"><span>mov</span><span> </span><span>ecx</span><span>,</span><span> </span><span>0x59E4D3C</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L7" data-line-number="7"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC7"><span>call</span><span> CORINFO_HELP_NEWSFAST</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L8" data-line-number="8"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC8"><span>mov</span><span> </span><span>ecx</span><span>,</span><span> </span><span>eax</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L9" data-line-number="9"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC9"><span>lea</span><span> </span><span>edx</span><span>,</span><span> bword ptr </span><span>[</span><span>ecx</span><span>+</span><span>4</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L10" data-line-number="10"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC10"><span>call</span><span> CORINFO_HELP_ASSIGN_REF_ESI</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L11" data-line-number="11"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC11"><span>call</span><span> </span><span>[</span><span>IPrint:Print():this</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L12" data-line-number="12"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC12"><span>mov</span><span> </span><span>eax</span><span>,</span><span> </span><span>100</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L13" data-line-number="13"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC13"><span>pop</span><span> </span><span>esi</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L14" data-line-number="14"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC14"><span>pop</span><span> </span><span>ebp</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L15" data-line-number="15"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC15"><span>ret</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L16" data-line-number="16"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC16"></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L17" data-line-number="17"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC17"><span>// ...which calls to X&lt;T&gt;.Print:</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L18" data-line-number="18"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC18"><span>push</span><span> </span><span>ebp</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L19" data-line-number="19"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC19"><span>mov</span><span> </span><span>ebp</span><span>,</span><span> </span><span>esp</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L20" data-line-number="20"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC20"><span>push</span><span> </span><span>eax</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L21" data-line-number="21"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC21"><span>mov</span><span> dword ptr </span><span>[</span><span>ebp</span><span>-</span><span>04H</span><span>],</span><span> </span><span>edx</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L22" data-line-number="22"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC22"><span>mov</span><span> </span><span>ecx</span><span>,</span><span> gword ptr </span><span>[</span><span>ecx</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L23" data-line-number="23"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC23"><span>call</span><span> </span><span>[</span><span>System.Console:WriteLine(ref)</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L24" data-line-number="24"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC24"><span>mov</span><span> </span><span>esp</span><span>,</span><span> </span><span>ebp</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L25" data-line-number="25"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC25"><span>pop</span><span> </span><span>ebp</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_20-asm-L26" data-line-number="26"></td><td id="file-perfblog04162018_jitoverallexample_20-asm-LC26"><span>ret</span></td></tr></tbody></table>

In contrast, in .NET Core 2.1, that’s all consolidated to this being generated for Main:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_JitOverallExample_21.asm"><tbody><tr><td id="file-perfblog04162018_jitoverallexample_21-asm-L1" data-line-number="1"></td><td id="file-perfblog04162018_jitoverallexample_21-asm-LC1"><span>mov</span><span> </span><span>ecx</span><span>,</span><span> gword ptr </span><span>[</span><span>0859203CH</span><span>]</span><span> </span><span>'hello, world!'</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_21-asm-L2" data-line-number="2"></td><td id="file-perfblog04162018_jitoverallexample_21-asm-LC2"><span>call</span><span> </span><span>[</span><span>System.Console:WriteLine(ref)</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_21-asm-L3" data-line-number="3"></td><td id="file-perfblog04162018_jitoverallexample_21-asm-LC3"><span>mov</span><span> </span><span>eax</span><span>,</span><span> </span><span>100</span></td></tr><tr><td id="file-perfblog04162018_jitoverallexample_21-asm-L4" data-line-number="4"></td><td id="file-perfblog04162018_jitoverallexample_21-asm-LC4"><span>ret</span></td></tr></tbody></table>

Very nice.

## [](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1/#threading)Threading

Improvements to the JIT are an example of changes that can have very broad impact over large swaths of code. So, too, are changes to the runtime, and one key area where the runtime has seen significant improvements is in the area of threading. These improvements have come in a variety of forms, whether in reducing the overhead of low-level operations, or reducing lock contention in commonly used threading primitives, or reducing allocation, or generally improving the infrastructure behind async methods. Let’s look at a few examples.

A key need in writing scalable code is taking advantage of thread statics, which are fields unique to each thread. The overhead involved in accessing a thread static is greater than that for normal statics, and it’s important that this be as low as possible as lots of functionality, in the runtime, in the core libraries, and in user code, depends on them, often on hot paths (for example, `Int32.Parse(string)` looks up the current culture, which is stored in a thread static). PRs [dotnet/coreclr#14398](https://github.com/dotnet/coreclr/pull/14398) and [dotnet/coreclr#14560](https://github.com/dotnet/coreclr/pull/14560) significantly reduced this overhead involved in accessing thread statics. So, for example, this benchmark:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_ThreadStatics.cs"><tbody><tr><td id="file-perfblog04162018_threadstatics-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_threadstatics-cs-LC1"><span>[</span><span>Benchmark</span><span>(</span><span>OperationsPerInvoke</span> <span>=</span> <span>1_000_000</span><span>)</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_threadstatics-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_threadstatics-cs-LC2"><span>public</span> <span>void</span> <span>ThreadStatics</span><span>(</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_threadstatics-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_threadstatics-cs-LC3"><span>{</span></td></tr><tr><td id="file-perfblog04162018_threadstatics-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_threadstatics-cs-LC4"><span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>1_000_000</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>GetThreadStatic</span><span>(</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_threadstatics-cs-L5" data-line-number="5"></td><td id="file-perfblog04162018_threadstatics-cs-LC5"><span>}</span></td></tr><tr><td id="file-perfblog04162018_threadstatics-cs-L6" data-line-number="6"></td><td id="file-perfblog04162018_threadstatics-cs-LC6"></td></tr><tr><td id="file-perfblog04162018_threadstatics-cs-L7" data-line-number="7"></td><td id="file-perfblog04162018_threadstatics-cs-LC7"><span>[</span><span>MethodImpl</span><span>(</span><span>MethodImplOptions</span><span>.</span><span>NoInlining</span><span>)</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_threadstatics-cs-L8" data-line-number="8"></td><td id="file-perfblog04162018_threadstatics-cs-LC8"><span>private</span> <span><span>static</span></span> <span>object</span> <span>GetThreadStatic</span><span>(</span><span>)</span> <span>=&gt;</span> <span>t_threadStaticValue</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_threadstatics-cs-L9" data-line-number="9"></td><td id="file-perfblog04162018_threadstatics-cs-LC9"></td></tr><tr><td id="file-perfblog04162018_threadstatics-cs-L10" data-line-number="10"></td><td id="file-perfblog04162018_threadstatics-cs-LC10"><span>[</span><span>ThreadStatic</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_threadstatics-cs-L11" data-line-number="11"></td><td id="file-perfblog04162018_threadstatics-cs-LC11"><span>private</span> <span><span>static</span></span> <span>object</span> <span>t_threadStaticValue</span> <span>=</span> <span>null</span><span>;</span></td></tr></tbody></table>

yields these results on my machine:

| Method | Toolchain | Mean |
| --- | --- | --- |
| ThreadStatics | .NET Core 2.0 | 7.322 ns |
| ThreadStatics | .NET Core 2.1 | 5.269 ns |

Whereas these thread statics changes were focused on improving the throughput of an individual piece of code, other changes focused on scalability and minimizing contention between pieces of code, in various ways. For example, PR [dotnet/coreclr#14216](https://github.com/dotnet/coreclr/pull/14216) focused on costs involved in `Monitor` (what’s used under the covers by `lock` in C#) when there’s contention, PR [dotnet/coreclr#13243](https://github.com/dotnet/coreclr/pull/13243) focused on the scalability of `ReaderWriterLockSlim`, and PR [dotnet/coreclr#14527](https://github.com/dotnet/coreclr/pull/14527) focused on reducing the contention in `Timer`s. Let’s take the last one as an example. Whenever a `System.Threading.Timer` is created, modified, fired, or removed, in .NET Core 2.0 that required taking a global timers lock; that meant that code which created lots of timers quickly would often end up serializing on this lock. To address this, .NET Core 2.1 partitions the timers across multiple locks, so that different threads running on different cores are less likely to contend with each other. The impact of that is visible in a benchmark like the following:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_TimerContention.cs"><tbody><tr><td id="file-perfblog04162018_timercontention-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_timercontention-cs-LC1"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_timercontention-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_timercontention-cs-LC2"><span>public</span> <span>void</span> <span>TimerContention</span><span>(</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_timercontention-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_timercontention-cs-LC3"><span>{</span></td></tr><tr><td id="file-perfblog04162018_timercontention-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_timercontention-cs-LC4"><span>var</span> <span>tasks</span> <span>=</span> <span>new</span> <span>Task</span><span>[</span><span>Environment</span><span>.</span><span>ProcessorCount</span><span>]</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_timercontention-cs-L5" data-line-number="5"></td><td id="file-perfblog04162018_timercontention-cs-LC5"><span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>tasks</span><span>.</span><span>Length</span><span>;</span> <span>i</span><span>++</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_timercontention-cs-L6" data-line-number="6"></td><td id="file-perfblog04162018_timercontention-cs-LC6"><span>{</span></td></tr><tr><td id="file-perfblog04162018_timercontention-cs-L7" data-line-number="7"></td><td id="file-perfblog04162018_timercontention-cs-LC7"><span>tasks</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>Task</span><span>.</span><span>Run</span><span>(</span><span>async</span> <span>(</span><span>)</span> <span>=&gt;</span></td></tr><tr><td id="file-perfblog04162018_timercontention-cs-L8" data-line-number="8"></td><td id="file-perfblog04162018_timercontention-cs-LC8"><span>{</span></td></tr><tr><td id="file-perfblog04162018_timercontention-cs-L9" data-line-number="9"></td><td id="file-perfblog04162018_timercontention-cs-LC9"><span>for</span> <span>(</span><span>int</span> <span>j</span> <span>=</span> <span>0</span><span>;</span> <span>j</span> <span>&lt;</span> <span>50_000</span><span>;</span> <span>j</span><span>++</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_timercontention-cs-L10" data-line-number="10"></td><td id="file-perfblog04162018_timercontention-cs-LC10"><span>{</span></td></tr><tr><td id="file-perfblog04162018_timercontention-cs-L11" data-line-number="11"></td><td id="file-perfblog04162018_timercontention-cs-LC11"><span>using</span> <span>(</span><span>var</span> <span>t</span> <span>=</span> <span>new</span> <span>Timer</span><span>(</span><span>delegate</span> <span>{</span> <span>}</span><span>,</span> <span>null</span><span>,</span> <span>100_000</span><span>,</span> <span>-</span><span>1</span><span>)</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_timercontention-cs-L12" data-line-number="12"></td><td id="file-perfblog04162018_timercontention-cs-LC12"><span>{</span></td></tr><tr><td id="file-perfblog04162018_timercontention-cs-L13" data-line-number="13"></td><td id="file-perfblog04162018_timercontention-cs-LC13"><span>await</span> <span>Task</span><span>.</span><span>Yield</span><span>(</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_timercontention-cs-L14" data-line-number="14"></td><td id="file-perfblog04162018_timercontention-cs-LC14"><span>}</span></td></tr><tr><td id="file-perfblog04162018_timercontention-cs-L15" data-line-number="15"></td><td id="file-perfblog04162018_timercontention-cs-LC15"><span>}</span></td></tr><tr><td id="file-perfblog04162018_timercontention-cs-L16" data-line-number="16"></td><td id="file-perfblog04162018_timercontention-cs-LC16"><span>}</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_timercontention-cs-L17" data-line-number="17"></td><td id="file-perfblog04162018_timercontention-cs-LC17"><span>}</span></td></tr><tr><td id="file-perfblog04162018_timercontention-cs-L18" data-line-number="18"></td><td id="file-perfblog04162018_timercontention-cs-LC18"><span>Task</span><span>.</span><span>WaitAll</span><span>(</span><span>tasks</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_timercontention-cs-L19" data-line-number="19"></td><td id="file-perfblog04162018_timercontention-cs-LC19"><span>}</span></td></tr></tbody></table>

This spawns multiple tasks, each of which creates a timer, does a bit of work, and then deletes the timer, and it yields the following results on my quad-core:

| Method | Toolchain | Mean |
| --- | --- | --- |
| TimerContention | .NET Core 2.0 | 332.8 ms |
| TimerContention | .NET Core 2.1 | 135.6 ms |

Another significant improvement came in the form of both throughput improvement and allocation reduction, in `CancellationTokenSource`. `CancellationToken`s have become ubiquitous throughout the framework, in particular in asynchronous methods. It’s often the case that a single token will be created for the lifetime of some composite operation (e.g the handling of a web request), and over its lifetime, it’ll be passed in and out of many sub-operations, each of which will `Register` a callback with the token for the duration of that sub-operation. In .NET Core 2.0 and previous .NET releases, the implementation was heavily focused on getting as much scalability as possible, achieved via a set of lock-free algorithms that were scalable but that incurred non-trivial costs in both throughput and allocation, so much so that it overshadowed the benefits of the lock-freedom. The associated level of scalability is also generally unnecessary, as the primary use case for a single `CancellationToken` does not involve many parallel operations, but instead many serialized operations one after the other. In .NET Core 2.1, PR [dotnet/coreclr#12819](https://github.com/dotnet/coreclr/pull/12819) changed the implementation to prioritize the more common scenarios; it’s still very scalable, but by switching away from a lock-free algorithm to one that instead employed striped locking (as in the `Timer` case), we significantly reduced allocations and improved throughput while still meeting scalability goals. These improvements can be seen from the following single-threaded benchmark:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_CancellationTokenRegistration_Serial.cs"><tbody><tr><td id="file-perfblog04162018_cancellationtokenregistration_serial-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_cancellationtokenregistration_serial-cs-LC1"><span>private</span> <span><span>static</span></span> <span>readonly</span> <span>CancellationToken</span> <span>s_token</span> <span>=</span> <span>new</span> <span>CancellationTokenSource</span><span>(</span><span>)</span><span>.</span><span>Token</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_cancellationtokenregistration_serial-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_cancellationtokenregistration_serial-cs-LC2"></td></tr><tr><td id="file-perfblog04162018_cancellationtokenregistration_serial-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_cancellationtokenregistration_serial-cs-LC3"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_cancellationtokenregistration_serial-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_cancellationtokenregistration_serial-cs-LC4"><span>public</span> <span>void</span> <span>SerialCancellationTokenRegistration</span><span>(</span><span>)</span> <span>=&gt;</span></td></tr><tr><td id="file-perfblog04162018_cancellationtokenregistration_serial-cs-L5" data-line-number="5"></td><td id="file-perfblog04162018_cancellationtokenregistration_serial-cs-LC5"><span>s_token</span><span>.</span><span>Register</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>}</span><span>)</span><span>.</span><span>Dispose</span><span>(</span><span>)</span><span>;</span></td></tr></tbody></table>

| Method | Toolchain | Mean | Allocated |
| --- | --- | --- | --- |
| SerialCancellationTokenRegistration | .NET Core 2.0 | 95.29 ns | 48 B |
| SerialCancellationTokenRegistration | .NET Core 2.1 | 62.45 ns | 0 B |

and also from this multi-threaded one (run on a quad-core):

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_CancellationTokenRegistration_Parallel.cs"><tbody><tr><td id="file-perfblog04162018_cancellationtokenregistration_parallel-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_cancellationtokenregistration_parallel-cs-LC1"><span>private</span> <span><span>static</span></span> <span>readonly</span> <span>CancellationToken</span> <span>s_token</span> <span>=</span> <span>new</span> <span>CancellationTokenSource</span><span>(</span><span>)</span><span>.</span><span>Token</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_cancellationtokenregistration_parallel-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_cancellationtokenregistration_parallel-cs-LC2"></td></tr><tr><td id="file-perfblog04162018_cancellationtokenregistration_parallel-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_cancellationtokenregistration_parallel-cs-LC3"><span>[</span><span>Benchmark</span><span>(</span><span>OperationsPerInvoke</span> <span>=</span> <span>1_000_000</span><span>)</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_cancellationtokenregistration_parallel-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_cancellationtokenregistration_parallel-cs-LC4"><span>public</span> <span>void</span> <span>ParallelCancellationTokenRegistration</span><span>(</span><span>)</span> <span>=&gt;</span></td></tr><tr><td id="file-perfblog04162018_cancellationtokenregistration_parallel-cs-L5" data-line-number="5"></td><td id="file-perfblog04162018_cancellationtokenregistration_parallel-cs-LC5"><span>Parallel</span><span>.</span><span>For</span><span>(</span><span>0</span><span>,</span> <span>1_000_000</span><span>,</span> i <span>=&gt;</span> <span>s_token</span><span>.</span><span>Register</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>}</span><span>)</span><span>.</span><span>Dispose</span><span>(</span><span>)</span><span>)</span><span>;</span></td></tr></tbody></table>

| Method | Toolchain | Mean |
| --- | --- | --- |
| ParallelCancellationTokenRegistration | .NET Core 2.0 | 31.31 ns |
| ParallelCancellationTokenRegistration | .NET Core 2.1 | 18.19 ns |

These improvements to `CancellationToken` are just a piece of a larger set of improvements that have gone into async methods in .NET Core 2.1. As more and more code is written to be asynchronous and to use C#’s `async`/`await` features, it becomes more and more important that async methods introduce as little overhead as possible. Some significant strides in that regard have been taken in .NET Core 2.1, on a variety of fronts.

For example, on very hot paths that invoke asynchronous methods, one cost that shows up is simply the overhead involved in invoking an async method and awaiting it, in particular when it completes quickly and synchronously. In part due to the aforementioned JIT and thread static changes, and in part due to PRs like [dotnet/coreclr#15629](https://github.com/dotnet/coreclr/pull/15629) from [@benaadams](https://github.com/benaadams), this overhead has been cut by ~30%:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_AsyncMethodAwaitInvocation.cs"><tbody><tr><td id="file-perfblog04162018_asyncmethodawaitinvocation-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_asyncmethodawaitinvocation-cs-LC1"><span>[</span><span>Benchmark</span><span>(</span><span>OperationsPerInvoke</span> <span>=</span> <span>10_000</span><span>)</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_asyncmethodawaitinvocation-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_asyncmethodawaitinvocation-cs-LC2"><span>public</span> <span>async</span> <span>Task</span> <span>AsyncMethodAwaitInvocation</span><span>(</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_asyncmethodawaitinvocation-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_asyncmethodawaitinvocation-cs-LC3"><span>{</span></td></tr><tr><td id="file-perfblog04162018_asyncmethodawaitinvocation-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_asyncmethodawaitinvocation-cs-LC4"><span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>10_000</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>await</span> <span>MethodAsync</span><span>(</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_asyncmethodawaitinvocation-cs-L5" data-line-number="5"></td><td id="file-perfblog04162018_asyncmethodawaitinvocation-cs-LC5"><span>}</span></td></tr><tr><td id="file-perfblog04162018_asyncmethodawaitinvocation-cs-L6" data-line-number="6"></td><td id="file-perfblog04162018_asyncmethodawaitinvocation-cs-LC6"></td></tr><tr><td id="file-perfblog04162018_asyncmethodawaitinvocation-cs-L7" data-line-number="7"></td><td id="file-perfblog04162018_asyncmethodawaitinvocation-cs-LC7"><span>private</span> <span>async</span> <span>Task</span> <span>MethodAsync</span><span>(</span><span>)</span> <span>{</span> <span>}</span></td></tr></tbody></table>

| Method | Toolchain | Mean | Allocated |
| --- | --- | --- | --- |
| AsyncMethodAwaitInvocation | .NET Core 2.0 | 20.36 ns | 0 B |
| AsyncMethodAwaitInvocation | .NET Core 2.1 | 13.48 ns | 0 B |

Bigger improvements, however, have come in the form of allocation reduction. In previous releases of .NET, the synchronous completion path for async methods was optimized for allocations, meaning that if an async method completed without ever suspending, it either wouldn’t allocate at all or at most would allocate one object (for the returned `Task<T>` if an internally cached one wasn’t available). However, asynchronous completion (where it suspends at least once) would incur multiple allocations. The first allocation would be for the returned `Task`/`Task<T>` object, as the caller needs some object to hold onto to be able to know when the asynchronous operation has completed and to extract its result or exception. The second allocation is the boxing of the compiler-generated state machine: the “locals” for the async method start out on the stack, but when the method suspends, the state machine that contains these “locals” as fields gets boxed to the heap so that the data can survive across the await point. The third allocation is the `Action` delegate that’s passed to an awaiter and that’s used to move the state machine forward when the awaited object completes. And the fourth is a “runner” that stores additional context (e.g. ExecutionContext). These allocations can be seen by looking at a memory trace. For example, if we run this code:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_AsyncMethodYieldExample.cs"><tbody><tr><td id="file-perfblog04162018_asyncmethodyieldexample-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_asyncmethodyieldexample-cs-LC1"><span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>1000</span><span>;</span> <span>i</span><span>++</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_asyncmethodyieldexample-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_asyncmethodyieldexample-cs-LC2"><span>{</span></td></tr><tr><td id="file-perfblog04162018_asyncmethodyieldexample-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_asyncmethodyieldexample-cs-LC3"><span>await</span> <span>Yield</span><span>(</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_asyncmethodyieldexample-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_asyncmethodyieldexample-cs-LC4"><span>async</span> <span>Task</span> <span>Yield</span><span>(</span><span>)</span> <span>=&gt;</span> <span>await</span> <span>Task</span><span>.</span><span>Yield</span><span>(</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_asyncmethodyieldexample-cs-L5" data-line-number="5"></td><td id="file-perfblog04162018_asyncmethodyieldexample-cs-LC5"><span>}</span></td></tr></tbody></table>

and look at the results from the Visual Studio allocation profiler, in .NET Core 2.0 we see these allocations associated with the async infrastructure:

[![](https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2018/04/AsyncMethodAllocations_Before.png)](https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2018/04/AsyncMethodAllocations_Before.png)

Due to PRs like [dotnet/coreclr#13105](https://github.com/dotnet/coreclr/pull/13105), [dotnet/coreclr#14178](https://github.com/dotnet/coreclr/pull/14178) and [dotnet/coreclr#13907](https://github.com/dotnet/coreclr/pull/13907), the previous trace when run with .NET Core 2.1 instead looks like this:

[![](https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2018/04/AsyncMethodAllocations_After.png)](https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2018/04/AsyncMethodAllocations_After.png)

The four allocations have been reduced to one, and the total bytes allocated has shrunk by half. When async methods are used heavily in an application, that savings adds up quickly. There have also been side benefits to the architectural changes that enabled these savings, including improved debuggability.

## [](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1/#string)String

Moving up the stack, another area that’s seen a lot of performance love in .NET Core 2.1 is in commonly used primitive types, in particular `System.String`. Whether from vectorization, or using `System.Span<T>` and its optimizations internally, or adding fast paths for common scenarios, or reducing allocations, or simply trimming some fat, a bunch of functionality related to strings has gotten faster in 2.1. Let’s look at a few.

`String.Equal` is a workhorse of .NET applications, used for all manner of purposes, and thus it’s an ideal target for optimization. PR [dotnet/coreclr#16994](https://github.com/dotnet/coreclr/pull/16994) improved the performance of `String.Equal` by vectorizing it, utilizing the already vectorized implementation of `Span<T>.SequenceEqual` as its core implementation. The effect can be seen here, in the comparison of two strings that differ only in their last character:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_StringEquals.cs"><tbody><tr><td id="file-perfblog04162018_stringequals-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_stringequals-cs-LC1"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_stringequals-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_stringequals-cs-LC2"><span>public</span> <span>bool</span> <span>StringEquals</span><span>(</span><span>)</span> <span>=&gt;</span></td></tr><tr><td id="file-perfblog04162018_stringequals-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_stringequals-cs-LC3"><span>"All the world's a stage, and all the men and women merely players: they have their exits and their entrances; and one man in his time plays many parts, his acts being seven ages."</span></td></tr><tr><td id="file-perfblog04162018_stringequals-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_stringequals-cs-LC4"><span>.</span><span>Equals</span><span>(</span></td></tr><tr><td id="file-perfblog04162018_stringequals-cs-L5" data-line-number="5"></td><td id="file-perfblog04162018_stringequals-cs-LC5"><span>"All the world's a stage, and all the men and women merely players: they have their exits and their entrances; and one man in his time plays many parts, his acts being seven ages!"</span><span>)</span><span>;</span></td></tr></tbody></table>

| Method | Toolchain | Mean |
| --- | --- | --- |
| StringEquals | .NET Core 2.0 | 16.16 ns |
| StringEquals | .NET Core 2.1 | 10.20 ns |

`String.IndexOf` and `String.LastIndexOf` are similarly vectored with PR [dotnet/coreclr#16392](https://github.com/dotnet/coreclr/pull/16392):

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_StringIndexOf.cs"><tbody><tr><td id="file-perfblog04162018_stringindexof-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_stringindexof-cs-LC1"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_stringindexof-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_stringindexof-cs-LC2"><span>public</span> <span>void</span> <span>StringIndexOf</span><span>(</span><span>)</span> <span>=&gt;</span></td></tr><tr><td id="file-perfblog04162018_stringindexof-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_stringindexof-cs-LC3"><span>"All the world's a stage, and all the men and women merely players: they have their exits and their entrances; and one man in his time plays many parts, his acts being seven ages."</span></td></tr><tr><td id="file-perfblog04162018_stringindexof-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_stringindexof-cs-LC4"><span>.</span><span>IndexOf</span><span>(</span><span>'.'</span><span>)</span><span>;</span></td></tr></tbody></table>

| Method | Toolchain | Mean |
| --- | --- | --- |
| StringIndexOf | .NET Core 2.0 | 41.13 ns |
| StringIndexOf | .NET Core 2.1 | 15.94 ns |

`String.IndexOfAny` was also optimized. In contrast to the previous PRs that improved performance via vectorization, PR [dotnet/coreclr#13219](https://github.com/dotnet/coreclr/pull/13219) from [@bbowyersmyth](https://github.com/bbowyersmyth) improves the performance of `IndexOfAny` by special-casing the most commonly-used lengths of the `anyOf` characters array and adding fast-paths for them:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_StringIndexOfAny.cs"><tbody><tr><td id="file-perfblog04162018_stringindexofany-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_stringindexofany-cs-LC1"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_stringindexofany-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_stringindexofany-cs-LC2"><span>public</span> <span>int</span> <span>IndexOfAny</span><span>(</span><span>)</span> <span>=&gt;</span></td></tr><tr><td id="file-perfblog04162018_stringindexofany-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_stringindexofany-cs-LC3"><span>"All the world's a stage, and all the men and women merely players: they have their exits and their entrances; and one man in his time plays many parts, his acts being seven ages."</span></td></tr><tr><td id="file-perfblog04162018_stringindexofany-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_stringindexofany-cs-LC4"><span>.</span><span>IndexOfAny</span><span>(</span><span>s_chars</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_stringindexofany-cs-L5" data-line-number="5"></td><td id="file-perfblog04162018_stringindexofany-cs-LC5"></td></tr><tr><td id="file-perfblog04162018_stringindexofany-cs-L6" data-line-number="6"></td><td id="file-perfblog04162018_stringindexofany-cs-LC6"><span>private</span> <span><span>static</span></span> <span>readonly</span> <span>char</span><span>[</span><span>]</span> <span>s_chars</span> <span>=</span> <span>{</span> <span>':'</span><span>,</span> <span>';'</span> <span>}</span><span>;</span></td></tr></tbody></table>

| Method | Toolchain | Mean |
| --- | --- | --- |
| IndexOfAny | .NET Core 2.0 | 94.66 ns |
| IndexOfAny | .NET Core 2.1 | 38.27 ns |

`String.ToLower` and `ToUpper` (as well as the `ToLower/UpperInvariant` varieties) were improved in PR [dotnet/coreclr#17391](https://github.com/dotnet/coreclr/pull/17391). As with the previous PR, these were improved by adding fast-paths for common cases. First, if the string passed in is entirely ASCII, then it does all of the computation in managed code and avoids calling out to the native globalization library to do the casing. This in and of itself yields a significant throughput improvement, e.g.

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_StringToLowerChangesNeeded.cs"><tbody><tr><td id="file-perfblog04162018_stringtolowerchangesneeded-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_stringtolowerchangesneeded-cs-LC1"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_stringtolowerchangesneeded-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_stringtolowerchangesneeded-cs-LC2"><span>public</span> <span>string</span> <span>StringToLowerChangesNeeded</span><span>(</span><span>)</span> <span>=&gt;</span></td></tr><tr><td id="file-perfblog04162018_stringtolowerchangesneeded-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_stringtolowerchangesneeded-cs-LC3"><span>"This is a test to see what happens when we call ToLower."</span><span>.</span><span>ToLower</span><span>(</span><span>)</span><span>;</span></td></tr></tbody></table>

| Method | Toolchain | Mean | Allocated |
| --- | --- | --- | --- |
| StringToLowerChangesNeeded | .NET Core 2.0 | 187.00 ns | 144 B |
| StringToLowerChangesNeeded | .NET Core 2.1 | 96.29 ns | 144 B |

But things look even better when the string is already in the target casing:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_StringToLowerAlreadyCased.cs"><tbody><tr><td id="file-perfblog04162018_stringtoloweralreadycased-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_stringtoloweralreadycased-cs-LC1"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_stringtoloweralreadycased-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_stringtoloweralreadycased-cs-LC2"><span>public</span> <span>string</span> <span>StringToLowerAlreadyCased</span><span>(</span><span>)</span> <span>=&gt;</span></td></tr><tr><td id="file-perfblog04162018_stringtoloweralreadycased-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_stringtoloweralreadycased-cs-LC3"><span>"this is a test to see what happens when we call tolower."</span><span>.</span><span>ToLower</span><span>(</span><span>)</span><span>;</span></td></tr></tbody></table>

| Method | Toolchain | Mean | Allocated |
| --- | --- | --- | --- |
| StringToLowerAlreadyCased | .NET Core 2.0 | 197.21 ns | 144 B |
| StringToLowerAlreadyCased | .NET Core 2.1 | 68.81 ns | 0 B |

In particular, note that all allocation has been eliminated.

Another very common `String` API was improved to reduce allocation while also improving throughput. In .NET Core 2.0, `String.Split` allocates an `Int32[]` to track split locations in the string; PR [dotnet/coreclr#15435](https://github.com/dotnet/coreclr/pull/15435) from [@cod7alex](https://github.com/dotnet/) removed that and replaced it with either stack allocation or usage of `ArrayPool<int>.Shared`, depending on the input string’s length. Further, PR [dotnet/coreclr#15322](https://github.com/dotnet/coreclr/pull/15322) took advantage of span internally to improve the throughput of several common cases. The results of both of these can be seen in this benchmark:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_StringSplit.cs"><tbody><tr><td id="file-perfblog04162018_stringsplit-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_stringsplit-cs-LC1"><span>private</span> <span><span>static</span></span> <span>readonly</span> <span>char</span><span>[</span><span>]</span> <span>s_seps</span> <span>=</span> <span>new</span><span>[</span><span>]</span> <span>{</span> <span>','</span> <span>}</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_stringsplit-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_stringsplit-cs-LC2"></td></tr><tr><td id="file-perfblog04162018_stringsplit-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_stringsplit-cs-LC3"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_stringsplit-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_stringsplit-cs-LC4"><span>public</span> <span>string</span><span>[</span><span>]</span> <span>StringSplit</span><span>(</span><span>)</span> <span>=&gt;</span></td></tr><tr><td id="file-perfblog04162018_stringsplit-cs-L5" data-line-number="5"></td><td id="file-perfblog04162018_stringsplit-cs-LC5"><span>"All the world's a stage, and all the men and women merely players: they have their exits and their entrances; and one man in his time plays many parts, his acts being seven ages."</span></td></tr><tr><td id="file-perfblog04162018_stringsplit-cs-L6" data-line-number="6"></td><td id="file-perfblog04162018_stringsplit-cs-LC6"><span>.</span><span>Split</span><span>(</span><span>s_seps</span><span>)</span><span>;</span></td></tr></tbody></table>

| Method | Toolchain | Mean | Allocated |
| --- | --- | --- | --- |
| StringSplit | .NET Core 2.0 | 459.5 ns | 1216 B |
| StringSplit | .NET Core 2.1 | 305.2 ns | 480 B |

Even some corner cases of `String` usage saw improvements. For example, some developers use `String.Concat(IEnumerable<char>)` as a way to compose characters into strings. PR [dotnet/coreclr#14298](https://github.com/dotnet/coreclr/pull/14298) special-cased `T` == `char` in this overload, yielding some nice throughput and allocation wins:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_StringConcatCharEnumerable.cs"><tbody><tr><td id="file-perfblog04162018_stringconcatcharenumerable-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_stringconcatcharenumerable-cs-LC1"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_stringconcatcharenumerable-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_stringconcatcharenumerable-cs-LC2"><span>public</span> <span>string</span> <span>StringConcatCharEnumerable</span><span>(</span><span>)</span> <span>=&gt;</span></td></tr><tr><td id="file-perfblog04162018_stringconcatcharenumerable-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_stringconcatcharenumerable-cs-LC3"><span>string</span><span>.</span><span>Concat</span><span>(</span><span>Enumerable</span><span>.</span><span>Range</span><span>(</span><span>0</span><span>,</span> <span>1000</span><span>)</span><span>.</span><span>Select</span><span>(</span>i <span>=&gt;</span> <span>(</span><span>char</span><span>)</span><span>(</span><span>'a'</span> <span>+</span> <span>i</span> <span>%</span> <span>26</span><span>)</span><span>)</span><span>)</span><span>;</span></td></tr></tbody></table>

| Method | Toolchain | Mean | Allocated |
| --- | --- | --- | --- |
| StringConcatCharEnumerable | .NET Core 2.0 | 22.05 us | 35.82 KB |
| StringConcatCharEnumerable | .NET Core 2.1 | 15.56 us | 4.57 KB |

## [](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1/#formatting-and-parsing)Formatting and Parsing

The work done around strings also extends into the broad area of formatting and parsing, work that’s the bread-and-butter of many applications.

As noted at the beginning of this post, many `Span<T>`\-based methods were added across the framework, and while I’m not going to focus on those here from a new API perspective, the act of adding these APIs helped to improve existing APIs. Some existing APIs were improved by taking advantage of the new `Span<T>`\-based methods. For example, PR [dotnet/coreclr#15110](https://github.com/dotnet/coreclr/pull/15110) from [@justinvp](https://github.com/justinvp) utilizes the new `Span<T>`\-based `TryFormat` in `StringBuilder.AppendFormat`, which is itself used internally by `String.Format`. The usage of `Span<T>` enables the implementation internally to format directly into existing buffers rather than first formatting into allocated strings and then copying those strings to the destination buffer.

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_StringFormat.cs"><tbody><tr><td id="file-perfblog04162018_stringformat-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_stringformat-cs-LC1"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_stringformat-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_stringformat-cs-LC2"><span>public</span> <span>void</span> <span>StringFormat</span><span>(</span><span>)</span> <span>=&gt;</span> <span>string</span><span>.</span><span>Format</span><span>(</span><span>"Test {0}"</span><span>,</span> <span>123456789</span><span>)</span><span>;</span></td></tr></tbody></table>

| Method | Toolchain | Mean | Allocated |
| --- | --- | --- | --- |
| StringFormat | .NET Core 2.0 | 196.1 ns | 128 B |
| StringFormat | .NET Core 2.1 | 151.3 ns | 80 B |

Similarly, PR [dotnet/coreclr#15069](https://github.com/dotnet/coreclr/pull/15069) takes advantage of the `Span<T>`\-based methods in various `StringBuilder.Append` overloads, to format the provided value directly into the `StringBuilder`‘s buffer rather than going through a `String`:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_StringBuilderAppend.cs"><tbody><tr><td id="file-perfblog04162018_stringbuilderappend-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_stringbuilderappend-cs-LC1"><span>private</span> <span><span>static</span></span> <span>readonly</span> <span>StringBuilder</span> <span>s_builder</span> <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_stringbuilderappend-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_stringbuilderappend-cs-LC2"></td></tr><tr><td id="file-perfblog04162018_stringbuilderappend-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_stringbuilderappend-cs-LC3"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_stringbuilderappend-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_stringbuilderappend-cs-LC4"><span>public</span> <span>void</span> <span>StringBuilderAppend</span><span>(</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_stringbuilderappend-cs-L5" data-line-number="5"></td><td id="file-perfblog04162018_stringbuilderappend-cs-LC5"><span>{</span></td></tr><tr><td id="file-perfblog04162018_stringbuilderappend-cs-L6" data-line-number="6"></td><td id="file-perfblog04162018_stringbuilderappend-cs-LC6"><span>StringBuilder</span> <span>sb</span> <span>=</span> <span>s_builder</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_stringbuilderappend-cs-L7" data-line-number="7"></td><td id="file-perfblog04162018_stringbuilderappend-cs-LC7"><span>sb</span><span>.</span><span>Length</span> <span>=</span> <span>0</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_stringbuilderappend-cs-L8" data-line-number="8"></td><td id="file-perfblog04162018_stringbuilderappend-cs-LC8"></td></tr><tr><td id="file-perfblog04162018_stringbuilderappend-cs-L9" data-line-number="9"></td><td id="file-perfblog04162018_stringbuilderappend-cs-LC9"><span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>100_000</span><span>;</span> <span>i</span><span>++</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_stringbuilderappend-cs-L10" data-line-number="10"></td><td id="file-perfblog04162018_stringbuilderappend-cs-LC10"><span>sb</span><span>.</span><span>Append</span><span>(</span><span>i</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_stringbuilderappend-cs-L11" data-line-number="11"></td><td id="file-perfblog04162018_stringbuilderappend-cs-LC11"><span>}</span></td></tr></tbody></table>

| Method | Toolchain | Mean | Allocated |
| --- | --- | --- | --- |
| StringBuilderAppend | .NET Core 2.0 | 6.523 ms | 3992000 B |
| StringBuilderAppend | .NET Core 2.1 | 3.268 ms | 0 B |

Another way the new `Span<T>`\-based methods helped was as a motivational forcing function. In the .NET Framework and .NET Core 2.0 and earlier, most of the numeric parsing and formatting code in .NET was implemented in native code. Having that code as C++ made it a lot more difficult to add the new `Span<T>`\-based methods, which would ideally share most of their implementation with their `String`\-based forebearers. However, all of that C++ was previously ported to C# as part of enabling .NET Native, and all of that code then found its way into [corert](https://github.com/dotnet/corert), which also shares code with [coreclr](https://github.com/dotnet/coreclr). For the .NET Core 2.1 release, we thus deleted most of the native parsing/formatting code in coreclr and replaced it with the managed port, that’s now shared between coreclr and corert. With the implementation in managed code, it was then also easier to iterate and experiment with optimizations, so not only did the code move to managed and not only is it now used for both the `String`\-based and `Span<T>`\-based implementations, many aspects of it also got faster.

For example, via PRs like [dotnet/coreclr#15069](https://github.com/dotnet/coreclr/pull/15069) and [dotnet/coreclr#17432](https://github.com/dotnet/coreclr/pull/17432), throughput of `Int32.ToString()` approximately doubled:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_Int32Formatting.cs"><tbody><tr><td id="file-perfblog04162018_int32formatting-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_int32formatting-cs-LC1"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_int32formatting-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_int32formatting-cs-LC2"><span>public</span> <span>void</span> <span>Int32Formatting</span><span>(</span><span>)</span> <span>=&gt;</span> <span>123456789</span><span>.</span><span>ToString</span><span>(</span><span>)</span><span>;</span></td></tr></tbody></table>

| Method | Toolchain | Mean | Allocated |
| --- | --- | --- | --- |
| Int32Formatting | .NET Core 2.0 | 65.27 ns | 48 B |
| Int32Formatting | .NET Core 2.1 | 34.88 ns | 48 B |

while via PRs like [dotnet/coreclr#13389](https://github.com/dotnet/coreclr/pull/13389), Int32 parsing improved by over 20%:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_Int32Parsing.cs"><tbody><tr><td id="file-perfblog04162018_int32parsing-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_int32parsing-cs-LC1"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_int32parsing-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_int32parsing-cs-LC2"><span>public</span> <span>void</span> <span>Int32Parsing</span><span>(</span><span>)</span> <span>=&gt;</span> <span>int</span><span>.</span><span>Parse</span><span>(</span><span>"123456789"</span><span>)</span><span>;</span></td></tr></tbody></table>

| Method | Toolchain | Mean |
| --- | --- | --- |
| Int32Parsing | .NET Core 2.0 | 96.95 ns |
| Int32Parsing | .NET Core 2.1 | 76.99 ns |

These improvements aren’t limited to just integral types like `Int32`, `UInt32`, `Int64`, and `UInt64`. `Single.ToString()` and `Double.ToString()` improved as well, in particular on Unix where PR [dotnet/coreclr#12894](https://github.com/dotnet/coreclr/pull/12894) from [@mazong1123](https://github.com/mazong1123) provided an entirely new implementation for some very nice wins over the rather slow implementation that was there previously:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_DoubleFormatting.cs"><tbody><tr><td id="file-perfblog04162018_doubleformatting-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_doubleformatting-cs-LC1"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_doubleformatting-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_doubleformatting-cs-LC2"><span>public</span> <span>void</span> <span>DoubleFormatting</span><span>(</span><span>)</span> <span>=&gt;</span> <span>(</span><span>1234.5678</span><span>)</span><span>.</span><span>ToString</span><span>(</span><span>)</span><span>;</span></td></tr></tbody></table>

_Windows_:

| Method | Toolchain | Mean | Allocated |
| --- | --- | --- | --- |
| DoubleFormatting | .NET Core 2.0 | 448.7 ns | 48 B |
| DoubleFormatting | .NET Core 2.1 | 186.8 ns | 48 B |

_Linux_ (note that my Windows and Linux installations are running on very different setups, so the values shouldn’t be compared across OSes):

| Method | Toolchain | Mean | Allocated |
| --- | --- | --- | --- |
| DoubleFormatting | .NET Core 2.0 | 2,018.2 ns | 48 B |
| DoubleFormatting | .NET Core 2.1 | 258.1 ns | 48 B |

The improvements in 2.1 also apply to less commonly used but still important numerical types, such as via PR [dotnet/corefx#25353](https://github.com/dotnet/corefx/pull/25353) for `BigInteger`:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_BigIntegerFormatting.cs"><tbody><tr><td id="file-perfblog04162018_bigintegerformatting-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_bigintegerformatting-cs-LC1"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_bigintegerformatting-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_bigintegerformatting-cs-LC2"><span>public</span> <span>void</span> <span>BigIntegerFormatting</span><span>(</span><span>)</span> <span>=&gt;</span> <span>s_bi</span><span>.</span><span>ToString</span><span>(</span><span>"X"</span><span>)</span><span>;</span></td></tr></tbody></table>

| Method | Toolchain | Mean | Allocated |
| --- | --- | --- | --- |
| BigIntegerFormatting | .NET Core 2.0 | 36.677 us | 34.73 KB |
| BigIntegerFormatting | .NET Core 2.1 | 3.119 us | 3.27 KB |

Note both the 10x improvement in throughput and 10x reduction in allocation.

These improvements continue with other parsing and formatting routines. For example, in services in particular, `DateTime` and `DateTimeOffset` are often formatted using either the [`"r"`](https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#RFC1123) or [`"o"`](https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#Roundtrip) formats, both of which have been optimized in .NET Core 2.1, via PR [dotnet/coreclr#17092](https://github.com/dotnet/coreclr/pull/17092):

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_DateTimeFormatting.cs"><tbody><tr><td id="file-perfblog04162018_datetimeformatting-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_datetimeformatting-cs-LC1"><span>private</span> <span><span>static</span></span> <span>readonly</span> <span>DateTimeOffset</span> <span>s_dto</span> <span>=</span> <span>DateTimeOffset</span><span>.</span><span>UtcNow</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_datetimeformatting-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_datetimeformatting-cs-LC2"></td></tr><tr><td id="file-perfblog04162018_datetimeformatting-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_datetimeformatting-cs-LC3"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_datetimeformatting-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_datetimeformatting-cs-LC4"><span>public</span> <span>void</span> <span>DateTimeOffsetFormatR</span><span>(</span><span>)</span> <span>=&gt;</span> <span>s_dto</span><span>.</span><span>ToString</span><span>(</span><span>"r"</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_datetimeformatting-cs-L5" data-line-number="5"></td><td id="file-perfblog04162018_datetimeformatting-cs-LC5"></td></tr><tr><td id="file-perfblog04162018_datetimeformatting-cs-L6" data-line-number="6"></td><td id="file-perfblog04162018_datetimeformatting-cs-LC6"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_datetimeformatting-cs-L7" data-line-number="7"></td><td id="file-perfblog04162018_datetimeformatting-cs-LC7"><span>public</span> <span>void</span> <span>DateTimeOffsetFormatO</span><span>(</span><span>)</span> <span>=&gt;</span> <span>s_dto</span><span>.</span><span>ToString</span><span>(</span><span>"o"</span><span>)</span><span>;</span></td></tr></tbody></table>

| Method | Toolchain | Mean | Allocated |
| --- | --- | --- | --- |
| DateTimeOffsetFormatR | .NET Core 2.0 | 220.89 ns | 88 B |
| DateTimeOffsetFormatR | .NET Core 2.1 | 64.60 ns | 88 B |
|  |  |  |  |
| DateTimeOffsetFormatO | .NET Core 2.0 | 263.45 ns | 96 B |
| DateTimeOffsetFormatO | .NET Core 2.1 | 104.66 ns | 96 B |

Even `System.Convert` has gotten in on the formatting and parsing performance fun, with parsing from Base64 via `FromBase64Chars` and `FromBase64String` getting significant speedups, thanks to PR [dotnet/coreclr#17033](https://github.com/dotnet/coreclr/pull/17033):

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_ConverFromBase64.cs"><tbody><tr><td id="file-perfblog04162018_converfrombase64-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_converfrombase64-cs-LC1"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_converfrombase64-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_converfrombase64-cs-LC2"><span>public</span> <span>byte</span><span>[</span><span>]</span> <span>ConvertFromBase64String</span><span>(</span><span>)</span> <span>=&gt;</span> <span>Convert</span><span>.</span><span>FromBase64String</span><span>(</span><span>s_base64String</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_converfrombase64-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_converfrombase64-cs-LC3"></td></tr><tr><td id="file-perfblog04162018_converfrombase64-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_converfrombase64-cs-LC4"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_converfrombase64-cs-L5" data-line-number="5"></td><td id="file-perfblog04162018_converfrombase64-cs-LC5"><span>public</span> <span>byte</span><span>[</span><span>]</span> <span>ConvertFromBase64Chars</span><span>(</span><span>)</span> <span>=&gt;</span> <span>Convert</span><span>.</span><span>FromBase64CharArray</span><span>(</span><span>s_base64Chars</span><span>,</span> <span>0</span><span>,</span> <span>s_base64Chars</span><span>.</span><span>Length</span><span>)</span><span>;</span></td></tr></tbody></table>

| Method | Toolchain | Mean | Allocated |
| --- | --- | --- | --- |
| ConvertFromBase64String | .NET Core 2.0 | 45.99 us | 9.79 KB |
| ConvertFromBase64String | .NET Core 2.1 | 29.86 us | 9.79 KB |
|  |  |  |  |
| ConvertFromBase64Chars | .NET Core 2.0 | 46.34 us | 9.79 KB |
| ConvertFromBase64Chars | .NET Core 2.1 | 29.51 us | 9.79 KB |

## [](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1/#networking)Networking

The System.Net libraries received some good performance attention in .NET Core 2.0, but significantly more so in .NET Core 2.1.

There have been some nice improvements throughout the libraries, such as PR [dotnet/corefx#26850](https://github.com/dotnet/corefx/pull/26850) from [@JeffCyr](https://github.com/JeffCyr) improving `Dns.GetHostAddressAsync` on Windows with a true asynchronous implementation, or PR [dotnet/corefx#26303](https://github.com/dotnet/corefx/pull/26303) providing an optimized endian-reversing routine which was then used by PR [dotnet/corefx#26329](https://github.com/dotnet/corefx/pull/26329) from [@justinvp](https://github.com/justinvp) to optimize `IPAddress.HostToNetworkOrder`/`NetworkToHostOrder`:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_IPAddressNetworkToHostOrder.cs"><tbody><tr><td id="file-perfblog04162018_ipaddressnetworktohostorder-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_ipaddressnetworktohostorder-cs-LC1"><span>private</span> <span><span>static</span></span> <span>readonly</span> <span>long</span> <span>s_addr</span> <span>=</span> <span>IPAddress</span><span>.</span><span>Loopback</span><span>.</span><span>Address</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_ipaddressnetworktohostorder-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_ipaddressnetworktohostorder-cs-LC2"></td></tr><tr><td id="file-perfblog04162018_ipaddressnetworktohostorder-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_ipaddressnetworktohostorder-cs-LC3"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_ipaddressnetworktohostorder-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_ipaddressnetworktohostorder-cs-LC4"><span>public</span> <span>long</span> <span>IPAddressNetworkToHostOrder</span><span>(</span><span>)</span> <span>=&gt;</span> <span>IPAddress</span><span>.</span><span>NetworkToHostOrder</span><span>(</span><span>s_addr</span><span>)</span><span>;</span></td></tr></tbody></table>

| Method | Toolchain | Mean |
| --- | --- | --- |
| NetworkToHostOrder | .NET Core 2.0 | 10.760 ns |
| NetworkToHostOrder | .NET Core 2.1 | 1.461 ns |

or in PRs like [dotnet/corefx#28086](https://github.com/dotnet/corefx/pull/28086), [dotnet/corefx#28084](https://github.com/dotnet/corefx/pull/28084), and [dotnet/corefx#22872](https://github.com/dotnet/corefx/pull/22872) avoiding allocations in `Uri`:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_UriAllocations.cs"><tbody><tr><td id="file-perfblog04162018_uriallocations-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_uriallocations-cs-LC1"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_uriallocations-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_uriallocations-cs-LC2"><span>public</span> <span>string</span> <span>UriAllocations</span><span>(</span><span>)</span> <span>=&gt;</span> <span>new</span> <span>Uri</span><span>(</span><span>"http://127.0.0.1:80"</span><span>)</span><span>.</span><span>AbsoluteUri</span><span>;</span></td></tr></tbody></table>

| Method | Toolchain | Mean | Allocated |
| --- | --- | --- | --- |
| UriAllocations | .NET Core 2.0 | 997.6 ns | 1168 B |
| UriAllocations | .NET Core 2.1 | 650.6 ns | 672 B |

But the most impactful changes have come in higher-level types, in particular in `Socket`, `SslStream`, and `HttpClient`.

At the sockets layer, there have been a variety of improvements, but the impact is most noticeable on Unix, where PRs like [dotnet/corefx#23115](https://github.com/dotnet/corefx/pull/23115) and [dotnet/corefx#25402](https://github.com/dotnet/corefx/pull/25402) overhauled how socket operations are processed and the allocations they incur. This is visible in the following benchmark that repeatedly does receives that will always complete asynchronously, followed by sends to satisfy them, and which sees a 2x improvement in throughput:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_SocketReceiveThenSend.cs"><tbody><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC1"><span>private</span> <span><span>static</span></span> <span>byte</span><span>[</span><span>]</span> <span>s_buffer</span> <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>1</span><span>]</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC2"><span>private</span> <span><span>static</span></span> <span>NetworkStream</span> <span>s_client</span><span>,</span> <span>s_server</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC3"></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC4"><span>[</span><span>GlobalSetup</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L5" data-line-number="5"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC5"><span>public</span> <span>void</span> <span>CreateConnectedStreams</span><span>(</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L6" data-line-number="6"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC6"><span>{</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L7" data-line-number="7"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC7"><span>using</span> <span>(</span><span>var</span> <span>listener</span> <span>=</span> <span>new</span> <span>Socket</span><span>(</span><span>AddressFamily</span><span>.</span><span>InterNetwork</span><span>,</span> <span>SocketType</span><span>.</span><span>Stream</span><span>,</span> <span>ProtocolType</span><span>.</span><span>Tcp</span><span>)</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L8" data-line-number="8"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC8"><span>{</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L9" data-line-number="9"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC9"><span>listener</span><span>.</span><span>Bind</span><span>(</span><span>new</span> <span>IPEndPoint</span><span>(</span><span>IPAddress</span><span>.</span><span>Loopback</span><span>,</span> <span>0</span><span>)</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L10" data-line-number="10"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC10"><span>listener</span><span>.</span><span>Listen</span><span>(</span><span>1</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L11" data-line-number="11"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC11"></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L12" data-line-number="12"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC12"><span>var</span> <span>client</span> <span>=</span> <span>new</span> <span>Socket</span><span>(</span><span>AddressFamily</span><span>.</span><span>InterNetwork</span><span>,</span> <span>SocketType</span><span>.</span><span>Stream</span><span>,</span> <span>ProtocolType</span><span>.</span><span>Tcp</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L13" data-line-number="13"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC13"><span>client</span><span>.</span><span>Connect</span><span>(</span><span>listener</span><span>.</span><span>LocalEndPoint</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L14" data-line-number="14"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC14"><span>Socket</span> <span>server</span> <span>=</span> <span>listener</span><span>.</span><span>Accept</span><span>(</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L15" data-line-number="15"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC15"></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L16" data-line-number="16"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC16"><span>s_client</span> <span>=</span> <span>new</span> <span>NetworkStream</span><span>(</span><span>client</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L17" data-line-number="17"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC17"><span>s_server</span> <span>=</span> <span>new</span> <span>NetworkStream</span><span>(</span><span>server</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L18" data-line-number="18"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC18"><span>}</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L19" data-line-number="19"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC19"><span>}</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L20" data-line-number="20"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC20"></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L21" data-line-number="21"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC21"><span>[</span><span>GlobalCleanup</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L22" data-line-number="22"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC22"><span>public</span> <span>void</span> <span>DisposeStreams</span><span>(</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L23" data-line-number="23"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC23"><span>{</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L24" data-line-number="24"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC24"><span>s_client</span><span>?</span><span>.</span><span>Dispose</span><span>(</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L25" data-line-number="25"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC25"><span>s_server</span><span>?</span><span>.</span><span>Dispose</span><span>(</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L26" data-line-number="26"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC26"><span>}</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L27" data-line-number="27"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC27"></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L28" data-line-number="28"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC28"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L29" data-line-number="29"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC29"><span>public</span> <span>async</span> <span>Task</span> <span>SocketReceiveThenSend</span><span>(</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L30" data-line-number="30"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC30"><span>{</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L31" data-line-number="31"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC31"><span>byte</span><span>[</span><span>]</span> <span>buffer</span> <span>=</span> <span>s_buffer</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L32" data-line-number="32"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC32"><span>NetworkStream</span> <span>server</span> <span>=</span> <span>s_server</span><span>,</span> <span>client</span> <span>=</span> <span>s_client</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L33" data-line-number="33"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC33"><span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>1000</span><span>;</span> <span>i</span><span>++</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L34" data-line-number="34"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC34"><span>{</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L35" data-line-number="35"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC35"><span>var</span> <span>read</span> <span>=</span> <span>server</span><span>.</span><span>ReadAsync</span><span>(</span><span>buffer</span><span>,</span> <span>0</span><span>,</span> <span>buffer</span><span>.</span><span>Length</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L36" data-line-number="36"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC36"><span>await</span> <span>client</span><span>.</span><span>WriteAsync</span><span>(</span><span>buffer</span><span>,</span> <span>0</span><span>,</span> <span>buffer</span><span>.</span><span>Length</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L37" data-line-number="37"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC37"><span>await</span> <span>read</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L38" data-line-number="38"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC38"><span>}</span></td></tr><tr><td id="file-perfblog04162018_socketreceivethensend-cs-L39" data-line-number="39"></td><td id="file-perfblog04162018_socketreceivethensend-cs-LC39"><span>}</span></td></tr></tbody></table>

| Method | Toolchain | Mean |
| --- | --- | --- |
| SocketReceiveThenSend | .NET Core 2.0 | 102.82 ms |
| SocketReceiveThenSend | .NET Core 2.1 | 48.95 ms |

Often used on top of sockets and `NetworkStream`, `SslStream` was improved significantly in .NET Core 2.1, as well, in a few ways. First, PRs like [dotnet/corefx#24497](https://github.com/dotnet/corefx/pull/24497) and [dotnet/corefx#23715](https://github.com/dotnet/corefx/pull/23715) from [@Drawaes](https://github.com/Drawaes), as well as [dotnet/corefx#22304](https://github.com/dotnet/corefx/pull/22304) and [dotnet/corefx#29031](https://github.com/dotnet/corefx/pull/29031) helped to clean up the `SslStream` codebase, making it easier to improve in the future but also removing a bunch of allocations (above and beyond the significant allocation reductions that were seen in .NET Core 2.0). Second, though, a significant scalability bottleneck in `SslStream` on Unix was fixed in PR [dotnet/corefx#25646](https://github.com/dotnet/corefx/pull/25646) from [@Drawaes](https://github.com/Drawaes), such that `SslStream` now scales well on Unix as concurrent usage increases. This, in concert with the sockets improvements and other lower-level improvements, contributes to the managed implementation beneath `HttpClient`.

`HttpClient` is a thin wrapper around an `HttpMessageHandler`, a public abstract class that represents an implementation of an HTTP client. A general-purpose implementation of `HttpMessageHandler` is provided in the form of the derived `HttpClientHandler` class, and while it’s possible to construct and pass a handler like `HttpClientHandler` to an `HttpClient` constructor (generally done to be able to configure the handler via its properties), `HttpClient` also provides a parameterless constructor that uses `HttpClientHandler` implicitly. In .NET Core 2.0 and earlier, `HttpClientHandler` was implemented on Windows on top of the native WinHTTP library, and it was implemented on Unix on top of the libcurl library. That dependency on the underlying external library has led to a variety of problems, including different behaviors across platforms and OS distributions as well as limited functionality on some platforms. In .NET Core 2.1, `HttpClientHandler` has a new default implementation implemented from scratch entirely in C# on top of the other System.Net libraries, e.g. System.Net.Sockets, System.Net.Security, etc. Not only does this address the aforementioned behavioral issues, it provides a significant boost in performance (the implementation is also exposed publicly as `SocketsHttpHandler`, which can be used directly instead of via `HttpClientHandler` in order to configure `SocketsHttpHandler`\-specific properties).

Here’s an example benchmark making a bunch of concurrent HTTPS calls to an in-process socket server:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_ConcurrentHttpsGets.cs"><tbody><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC1"><span>private</span> <span><span>static</span></span> <span>readonly</span> <span>byte</span><span>[</span><span>]</span> <span>s_testCertBytes</span> <span>=</span> <span>Convert</span><span>.</span><span>FromBase64String</span><span>(</span><span>@"MIIVBAIBAzCCFMAGCSqGSIb3DQEHAaCCFLEEghStMIIUqTCCCooGCSqGSIb3DQEHAaCCCnsEggp3MIIKczCCCm8GCyqGSIb3DQEMCgECoIIJfjCCCXowHAYKKoZIhvcNAQwBAzAOBAhCAauyUWggWwICB9AEgglYefzzX/jx0b+BLU/TkAVj1KBpojf0o6qdTXV42drqIGhX/k1WwF1ypVYdHeeuDfhH2eXHImwPTw+0bACY0dSiIHKptm0sb/MskoGI8nlOtHWLi+QBirJ9LSUZcBNOLwoMeYLSFEWWBT69k/sWrc6/SpDoVumkfG4pZ02D9bQgs1+k8fpZjZGoZp1jput8CQXPE3JpCsrkdSdiAbWdbNNnYAy4C9Ej/vdyXJVdBTEsKzPYajAzo6Phj/oS/J3hMxxbReMtj2Z0QkoBBVMc70d+DpAK5OY3et872D5bZjvxhjAYh5JoVTCLTLjbtPRn1g7qh2dQsIpfQ5KrdgqdImshHvxgL92ooC1eQVqQffMnZ0/LchWNb2rMDa89K9CtAefEIF4ve2bOUZUNFqQ6dvd90SgKq6jNfwQf/1u70WKE86+vChXMMcHFeKso6hTE9+/zuUPNVmbRefYAtDd7ng996S15FNVdxqyVLlmfcihX1jGhTLi//WuMEaOfXJ9KiwYUyxdUnMp5QJqO8X/tiwnsuhlFe3NKMXY77jUe8F7I+dv5cjb9iKXAT+q8oYx1LcWu2mj1ER9/b2omnotp2FIaJDwI40Tts6t4QVH3bUNE9gFIfTMK+WMgKBz/JAGvC1vbPSdFsWIqwhl7mEYWx83HJp/+Uqp5f+d8m4phSan2rkHEeDjkUaoifLWHWDmL94SZBrgU6yGVK9dU82kr7jCSUTrnga8qDYsHwpQ22QZtu0aOJGepSwZU7NZNMiyX6QR2hI0CNMjvTK2VusHFB+qnvw+19DzaDT6P0KNPxwBwp07KMQm3HWTRNt9u6gKUmo5FHngoGte+TZdY66dAwCl0Pt+p1v18XlOB2KOQZKLXnhgikjOwYQxFr3oTb2MjsP6YqnSF9EpYpmiNySXiYmrYxVinHmK+5JBqoQCN2C3N24slZkYq+AYUTnNST7Ib2We3bBICOFdVUgtFITRW40T+0XZnIv8G1Kbaq/1avfWI/ieKKxyiYp/ZNXaxc+ycgpsSsAJEuhb83bUkSBpGg9PvFEF0DXm4ah67Ja1SSTmvrCnrOsWZXIpciexMWRGoKrdvd7Yzj9E8hiu+CGTC4T6+7FxVXJrjCg9zU9G2U6g7uxzoyjGj1wqkhxgvl9pPbz6/KqDRLOHCEwRF4qlWXhsJy4levxGtifFt6n7DWaNSsOUf8Nwpi+d4fd7LQ7B5tW/y+/vVZziORueruCWO4LnfPhpJ70g18uyN7KyzrWy29rpE46rfjZGGt0WDZYahObPbw6HjcqSOuzwRoJMxamQb2qsuQnaBS6Bhb5PAnY4SEA045odf/u9uC7mLom2KGNHHz6HrgEPas2UHoJLuxYvY1pza/29akuVQZQUvMA5yMFHHGYZLtTKtCGdVGwX0+QS6ovpV93xux4I/5TrD5U8z9RmTdAx03R3MUhkHF7Zbv5egDNsVar+41YWG4VkV1ZXtsZRKJf0hvKNvrpH0e7fVKBdXljm5PXOSg2VdtkhhOpnKKSMcv6MbGWVi/svWLnc7Qim4A4MDaz+bFVZmh3oGJ7WHvRQhWIcHUL+YJx+064+4IKXZJ/2a/+b2o7C8mJ3GGSBx831ADogg6MRWZx3UY19OZ8YMvpzmZEBRZZnm4KgNpj+SQnf6pGzD2cmnRhzG60LSNPb17iKbdoUAEMkgt2tlMKXpnt1r7qwsIoTt407cAdCEsUH7OU/AjfFmSkKJZ7vC5HweqZPnhgJgZ6LYHlfiRzUR1xeDg8JG0nb0vb7LUE4nGPy39/TxIGos7WNwGpG1QVL/8pKjFdjwREaR8e5CSTlQ7gxHV+G3FFvFGpA1p8cRFzlgE6khDLrSJIUkhkHMA3oFwwAzBNIKVXjToyxCogDqxWya0E1Hw5rVCS/zOCS1De2XQbXs//g46TW0wTJwvgNbs0xLShf3XB+23meeEsMTCR0+igtMMMsh5K/vBUGcJA27ru/KM9qEBcseb/tqCkhhsdj1dnH0HDmpgFf5DfVrjm+P6ickcF2b+Ojr9t7XHgFszap3COpEPGmeJqNOUTuU53tu/O774IBgqINMWvvG65yQwsEO06jRrFPRUGb0eH6UM4vC7wbKajnfDuI/EXSgvuOSZ9wE8DeoeK/5We4pN7MSWoDl39gI/LBoNDKFYEYuAw/bhGp8nOwDKki4a16aYcBGRClpN3ymrdurWsi7TjyFHXfgW8fZe4jXLuKRIk19lmL1gWyD+3bT3mkI2cU2OaY2C0fVHhtiBVaYbxBV8+kjK8q0Q70zf0r+xMHnewk9APFqUjguPguTdpCoH0VAQST9Mmriv/J12+Y+fL6H+jrtDY2zHPxTF85pA4bBBnLA7Qt9TKCe6uuWu5yBqxOV3w2Oa4Pockv1gJzFbVnwlEUWnIjbWVIyo9vo4LBd03uJHPPIQbUp9kCP/Zw+Zblo42/ifyY+a+scwl1q1dZ7Y0L92yJCKm9Qf6Q+1PBK+uU9pcuVTg/Imqcg5T7jFO5QCi88uwcorgQp+qoeFi0F9tnUecfDl6d0PSgAPnX9XA0ny3bPwSiWOA8+uW73gesxnGTsNrtc1j85tail8N6m6S2tHXwOmM65J4XRZlzzeM4D/Rzzh13xpRA9kzm9T2cSHsXEYmSW1X7WovrmYhdOh9K3DPwSyG4tD58cvC7X79UbOB+d17ieo7ZCj+NSLVQO1BqTK0QfErdoVHGKfQG8Lc/ERQRqj132Mhi2/r5Ca7AWdqD7/3wgRdQTJSFXt/akpM44xu5DMTCISEFOLWiseSOBtzT6ssaq2Q35dCkXp5wVbWxkXAD7Gm34FFXXyZrJWAx45Y40wj/0KDJoEzXCuS4Cyiskx1EtYNNOtfDC5wngywmINFUnnW0NkdKSxmDJvrT6HkRKN8ftik7tP4ZvTaTS28Z0fDmWJ+RjvZW+vtF6mrIzYgGOgdpZwG0ZOSKrXKrY3xpMO16fXyawFfBosLzCty7uA57niPS76UXdbplgPanIGFyceTg1MsNDsd8vszXd4KezN2VMaxvw+93s0Uk/3Mc+5MAj+UhXPi5UguXMhNo/CU7erzyxYreOlAI7ZzGhPk+oT9g/MqWa5RpA2IBUaK/wgaNaHChfCcDj/J1qEl6YQQboixxp1IjQxiV9bRQzgwf31Cu2m/FuHTTkPCdxDK156pyFdhcgTpTNy7RPLDGB3TATBgkqhkiG9w0BCRUxBgQEAQAAADBdBgkrBgEEAYI3EQExUB5OAE0AaQBjAHIAbwBzAG8AZgB0ACAAUwB0AHIAbwBuAGcAIABDAHIAeQBwAHQAbwBnAHIAYQBwAGgAaQBjACAAUAByAG8AdgBpAGQAZQByMGcGCSqGSIb3DQEJFDFaHlgAQwBlAHIAdABSAGUAcQAtADcAOQA4AGUANQA4AGIANQAtAGMAOQA2ADQALQA0ADcAZQA2AC0AYQAzADIAOQAtADAAMQBjAGEAZABmADcANgAyAGEANgA5MIIKFwYJKoZIhvcNAQcGoIIKCDCCCgQCAQAwggn9BgkqhkiG9w0BBwEwHAYKKoZIhvcNAQwBBjAOBAh+t0PMVhyoagICB9CAggnQwKPcfNq8ETOrNesDKNNYJVXnWoZ9Qjgj9RSpj+pUN5I3B67iFpXClvnglKbeNarNCzN4hXD0I+ce+u+Q3iy9AAthG7uyYYNBRjCWcBy25iS8htFUm9VoV9lH8TUnS63Wb/KZnowew2HVd8QI/AwQkRn8MJ200IxR/cFD4GuVO/Q76aqvmFb1BBHItTerUz7t9izjhL46BLabJKx6Csqixle7EoDOsTCA3H1Vmy2/Hw3FUtSUER23jnRgpRTA48M6/nhlnfjsjmegcnVBoyCgGaUadGE5OY42FDDUW7wT9VT6vQEiIfKSZ7fyqtZ6n4+xD2rVySVGQB9+ROm0mywZz9PufsYptZeB7AfNOunOAd2k1F5y3qT0cjCJ+l4eXr9KRd2lHOGZVoGq+e08ylBQU5HB+Tgm6mZaEO2QgzXOAt1ilS0lDii490DsST62+v58l2R45ItbRiorG/US7+HZHjHUY7EsDUZ+gn3ZZNqh1lAoli5bC1xcjEjNdqq0knyCAUaNMG59UhCWoB6lJpRfVEeQOm+TjgyGw6t3Fx/6ulNPc1V/wcascmahH3kgHL146iJi1p2c2yIJtEB+4zrbYv7xH73c8qXVh/VeuD80I/+QfD+GaW0MllIMyhCHcduFoUznHcDYr5GhJBhU62t6sNnSjtEU1bcd20oHrBwrpkA7g3/Mmny33IVrqooWFe876lvQVq7GtFu8ijVyzanZUs/Cr7k5xX3zjh6yUMAbPiSnTHCl+SEdttkR936fA6de8vIRRGj6eAKqboRxgC1zgsJrj7ZVI7h0QlJbodwY2jzyzcC5khn3tKYjlYeK08iQnzeK5c9JVgQAHyB4uOyfbE50oBCYJE7npjyV7LEN2f7a3GHX4ZWI3pTgbUv+Q1t8BZozQ4pcFQUE+upYucVL3Fr2T8f7HF4G4KbDE4aoLiVrYjy0dUs7rCgjeKu21UPA/BKx4ebjG+TZjUSGf8TXqrJak1PQOG4tExNBYxLtvBdFoOAsYsKjTOfMYpPXp4vObfktFKPcD1dVdlXYXvS5Dtz3qEkwmruA9fPQ6FYi+OFjw0Pkwkr5Tz+0hRMGgb1JRgVo8SVlW/NZZIEbKJdW5ZVLyMzdd1dC0ogNDZLPcPR/HENe2UXtq+0qQw0ekZ+aC2/RvfAMr5XICX8lHtYmQlAFGRhFNuOysHj7V2AJTuOx2wCXtGzrTPc6eyslsWyJign8bD1r+gkejx/qKBwwTvZF1aSmiQmFnmMm0jLj7n8v7v6zHCFTuKF1bHZ44eIwMaUDl6MAgHDdvkPl56rYgq/TM3dKuXnu47GLiRei0EXTT9OMCKcI6XYICsge81ET3k15VfLyI1LNufgqAsafnwl31yqntscXW0NsxW6SkmyXaW1mndxejLBQRjik3civBGTgxgKQbZaO9ZGOrjsSogcCSne+s0zLDxEFjmaYYtpIaU8SFWDja5jyo0jvM3OHUwvElvndZJgreFGG5cKHgwgGKdkYgx6YAvucrgQwqKE/+nxuhkKWtV9D4h9qFAqZbWc9jOPtWx9h3U3gX3NTLY/4Z4iy/FXR9KnKUtCmD1MSRRIOiMca1sNTga3mP/+qSS5u+pyon5c4c/jLdEW0GapDz/yvQcc0MP/21vSoeIkUN+w/RzUBvxrawhHGx+FeLlI249+LBKNBQu4Fbw6G9AYpPJf3PdNc0GRMnantA4B7Rm2NsSGdqqrEMuCw1XxzR6ki4jbLC/ASbcVMr54YsBw+45sggenFshRrYm0QXoUM5XoqEtesby6YfPAjBldyB/QcuULV6QyAeL44YmxOnKD5E5qQwgfcZUxN01eBgbeSS7bZI3zpFwAMdMQ+dtwHXMuhVXuUGLmNTvNe9DupfPGKbaM8louY1Xw4fmg4PaY7MP2mdYQlEXvSg2geICJVuGRBirH+Xv8VPr7lccN++LXv2NmggoUo/d18gvhY8XtOrOMon1QGANPh7SzBjR3v19JD170Z6GuZCLtMh681YkKwW/+Em5rOtexoNQRTjZLNSTthtMyLfAqLk6lZnbbh+7VdCWVfzZoOzUNV+fVwwvyR9ouIzrvDoZ5iGRZU8rEuntap6rBrf9F3FMsz4mvPlCAMp15sovLFpVI8t+8OmKmqQH3LOwd03s6iMJ+0YEWrCaTQYu3kEKoOWC3uhGE8XLSjZBqc3kwVIlzVzOBr97SGjG88JYVDW2FrjQbIv+1yTzOYzMnCDUW3T8GMtfYEQbN6ZtBaD9i4ZeZlQCdkfGuNC6OYO98L7fU4frgff8nNfeka8kHtvNMn4CosFKBRXA5y+kqEE0Qk5feZhfM8NX9x3O0CJobm4HC57VxJ3c0jTe2SA0gAfB4g0keghmDzYgjQAuIY/o1LMKFiBNue4fnXlhU1L402Zlx/lzKDera6o3Xgh9IXj3ZqyFlXa9bkyKDtek0ephTZulLc3NLeb1a3KZxId8OmplR8OcZsHluEu+Z3Der0j8Ro7X7kOnNkUxuTV2blqZ4V8DsYKATeKv4ffc1Ub8MLBd9hMs8ehjmC5jkYApM5HvXl4411mPN6MrF8f2hPVgqrd3p/M80c8wNWjvWIvPLr9Tjqk71hKBq3+Hu0oI1zuoTY2BOhBLyvpjM+mvRd8UlrFJTLGTyCAXvAhIDRIVyrGuscO5Y0sfDc+82Bvrua4FyhZkjb1r8GrGciH0V5HHKjg5dewWnr21qf4q96yf2/ZjoldFFvKiCd8wum9ZV1OaTbjjg46oSpIyBzxl4qpfrgT1ZX1MvGW4uAJ7WQHjSAex7VGr1Sl+ghe5PQBbURyFiu9PnBRMOMjGYkI2lngd3bdehc+i2fPnNe5LgdsBbmUKmEJH96rlkFT8Co+NYBWKBUsBXyfC+kwXDRyNrt2r7VafWWz/cwK0/AJ/Ucq4vz8E0mzy03Gs+ePW+tP9JOHP6leF0TLhbItvQl3DJy0gj6TyrO9S077EVyukFCXeH1/yp04lmq4G0urU+pUf2wamP4BVNcVsikPMYo/e75UI330inXG4+SbJ40q/MQIfYnXydhVmWVCUXkfRFNbcCu7JclIrzS1WO26q6BOgs2GhA3nEan8CKxa85h/oCaDPPMGhkQtCU75vBqQV9Hk2+W5zMSSj7R9RiH34MkCxETtY8IwKa+kiRAeMle8ePAmT6HfcBOdTsVGNoRHQAOZewwUycrIOYJ/54WOmcy9JZW9/clcgxHGXZq44tJ3BDHQQ4qBgVd5jc9Qy9/fGS3YxvsZJ3iN7IMs4Jt3GWdfvwNpJaCBJjiiUntJPwdXMjAeUEZ16Tmxdb1l42rjFSCptMJS2N2EPSNb36+staNgzflctLLpmyEK4wyqjA7MB8wBwYFKw4DAhoEFIM7fHJcmsN6HkU8HxypGcoifg5MBBRXe8XL349R6ZDmsMhpyXbXENCljwICB9A="</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC2"><span>private</span> <span><span>static</span></span> <span>Socket</span> <span>s_listener</span> <span>=</span> <span>new</span> <span>Socket</span><span>(</span><span>AddressFamily</span><span>.</span><span>InterNetwork</span><span>,</span> <span>SocketType</span><span>.</span><span>Stream</span><span>,</span> <span>ProtocolType</span><span>.</span><span>Tcp</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC3"><span>private</span> <span><span>static</span></span> <span>HttpClient</span> <span>s_client</span> <span>=</span> <span>new</span> <span>HttpClient</span><span>(</span><span>new</span> <span>HttpClientHandler</span><span>(</span><span>)</span> <span>{</span> <span>ServerCertificateCustomValidationCallback</span> <span>=</span> <span>delegate</span> <span>{</span> <span>return</span> <span>true</span><span>;</span> <span>}</span> <span>}</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC4"><span>private</span> <span><span>static</span></span> <span>Uri</span> <span>s_uri</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L5" data-line-number="5"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC5"></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L6" data-line-number="6"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC6"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L7" data-line-number="7"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC7"><span>public</span> <span>async</span> <span>Task</span> <span>ConcurrentHttpsGets</span><span>(</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L8" data-line-number="8"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC8"><span>{</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L9" data-line-number="9"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC9"><span>await</span> <span>Task</span><span>.</span><span>WhenAll</span><span>(</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L10" data-line-number="10"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC10"><span>Enumerable</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L11" data-line-number="11"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC11"><span>.</span><span>Range</span><span>(</span><span>0</span><span>,</span> <span>Environment</span><span>.</span><span>ProcessorCount</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L12" data-line-number="12"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC12"><span>.</span><span>Select</span><span>(</span><span>async</span> _ <span>=&gt;</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L13" data-line-number="13"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC13"><span>{</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L14" data-line-number="14"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC14"><span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>100</span><span>;</span> <span>i</span><span>++</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L15" data-line-number="15"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC15"><span>await</span> <span>s_client</span><span>.</span><span>GetStringAsync</span><span>(</span><span>s_uri</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L16" data-line-number="16"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC16"><span>}</span><span>)</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L17" data-line-number="17"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC17"><span>}</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L18" data-line-number="18"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC18"></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L19" data-line-number="19"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC19"><span>[</span><span>GlobalSetup</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L20" data-line-number="20"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC20"><span>public</span> <span>void</span> <span>CreateSocketServer</span><span>(</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L21" data-line-number="21"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC21"><span>{</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L22" data-line-number="22"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC22"><span>s_listener</span><span>.</span><span>Bind</span><span>(</span><span>new</span> <span>IPEndPoint</span><span>(</span><span>IPAddress</span><span>.</span><span>Loopback</span><span>,</span> <span>0</span><span>)</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L23" data-line-number="23"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC23"><span>s_listener</span><span>.</span><span>Listen</span><span>(</span><span>int</span><span>.</span><span>MaxValue</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L24" data-line-number="24"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC24"><span>var</span> <span>ep</span> <span>=</span> <span>(</span><span>IPEndPoint</span><span>)</span><span>s_listener</span><span>.</span><span>LocalEndPoint</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L25" data-line-number="25"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC25"><span>s_uri</span> <span>=</span> <span>new</span> <span>Uri</span><span>(</span><span><span>$</span>"https://<span>{</span><span>ep</span><span>.</span><span>Address</span><span>}</span>:<span>{</span><span>ep</span><span>.</span><span>Port</span><span>}</span>/"</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L26" data-line-number="26"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC26"></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L27" data-line-number="27"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC27"><span>Task</span><span>.</span><span>Run</span><span>(</span><span>async</span> <span>(</span><span>)</span> <span>=&gt;</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L28" data-line-number="28"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC28"><span>{</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L29" data-line-number="29"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC29"><span>while</span> <span>(</span><span>true</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L30" data-line-number="30"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC30"><span>{</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L31" data-line-number="31"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC31"><span>Socket</span> <span>s</span> <span>=</span> <span>await</span> <span>s_listener</span><span>.</span><span>AcceptAsync</span><span>(</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L32" data-line-number="32"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC32"><span>var</span> <span>ignored</span> <span>=</span> <span>Task</span><span>.</span><span>Run</span><span>(</span><span>async</span> <span>(</span><span>)</span> <span>=&gt;</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L33" data-line-number="33"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC33"><span>{</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L34" data-line-number="34"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC34"><span>using</span> <span>(</span><span>X509Certificate2</span> <span>serverCert</span> <span>=</span> <span>GetServerCertificate</span><span>(</span><span>)</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L35" data-line-number="35"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC35"><span>using</span> <span>(</span><span>var</span> <span>serverStream</span> <span>=</span> <span>new</span> <span>SslStream</span><span>(</span><span>new</span> <span>NetworkStream</span><span>(</span><span>s</span><span>,</span> <span>true</span><span>)</span><span>,</span> <span>false</span><span>,</span> <span>delegate</span> <span>{</span> <span>return</span> <span>true</span><span>;</span> <span>}</span><span>)</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L36" data-line-number="36"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC36"><span>{</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L37" data-line-number="37"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC37"><span>await</span> <span>serverStream</span><span>.</span><span>AuthenticateAsServerAsync</span><span>(</span><span>serverCert</span><span>,</span> <span>false</span><span>,</span> <span>SslProtocols</span><span>.</span><span>None</span><span>,</span> <span>false</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L38" data-line-number="38"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC38"><span>using</span> <span>(</span><span>var</span> <span>reader</span> <span>=</span> <span>new</span> <span>StreamReader</span><span>(</span><span>serverStream</span><span>)</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L39" data-line-number="39"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC39"><span>using</span> <span>(</span><span>var</span> <span>writer</span> <span>=</span> <span>new</span> <span>StreamWriter</span><span>(</span><span>serverStream</span><span>)</span> <span>{</span> <span>AutoFlush</span> <span>=</span> <span>true</span> <span>}</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L40" data-line-number="40"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC40"><span>{</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L41" data-line-number="41"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC41"><span>while</span> <span>(</span><span>true</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L42" data-line-number="42"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC42"><span>{</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L43" data-line-number="43"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC43"><span>while</span> <span>(</span><span>!</span><span>string</span><span>.</span><span>IsNullOrEmpty</span><span>(</span><span>await</span> <span>reader</span><span>.</span><span>ReadLineAsync</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>;</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L44" data-line-number="44"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC44"><span>await</span> <span>writer</span><span>.</span><span>WriteAsync</span><span>(</span><span>"HTTP/1.1 200 OK<span>\r</span><span>\n</span>Content-Length: 5<span>\r</span><span>\n</span><span>\r</span><span>\n</span>hello"</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L45" data-line-number="45"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC45"><span>}</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L46" data-line-number="46"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC46"><span>}</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L47" data-line-number="47"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC47"><span>}</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L48" data-line-number="48"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC48"><span>}</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L49" data-line-number="49"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC49"><span>}</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L50" data-line-number="50"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC50"><span>}</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L51" data-line-number="51"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC51"><span>}</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L52" data-line-number="52"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC52"></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L53" data-line-number="53"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC53"><span>private</span> <span><span>static</span></span> <span>X509Certificate2</span> <span>GetServerCertificate</span><span>(</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L54" data-line-number="54"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC54"><span>{</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L55" data-line-number="55"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC55"><span>var</span> <span>certCollection</span> <span>=</span> <span>new</span> <span>X509Certificate2Collection</span><span>(</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L56" data-line-number="56"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC56"><span>certCollection</span><span>.</span><span>Import</span><span>(</span><span>s_testCertBytes</span><span>,</span> <span>"testcertificate"</span><span>,</span> <span>X509KeyStorageFlags</span><span>.</span><span>DefaultKeySet</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L57" data-line-number="57"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC57"><span>return</span> <span>certCollection</span><span>.</span><span>Cast</span><span>&lt;</span><span>X509Certificate2</span><span>&gt;</span><span>(</span><span>)</span><span>.</span><span>First</span><span>(</span>c <span>=&gt;</span> <span>c</span><span>.</span><span>HasPrivateKey</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_concurrenthttpsgets-cs-L58" data-line-number="58"></td><td id="file-perfblog04162018_concurrenthttpsgets-cs-LC58"><span>}</span></td></tr></tbody></table>

On an 8-core Windows machine, here are my results:

| Method | Toolchain | Mean | Gen 0 | Gen 1 |
| --- | --- | --- | --- | --- |
| ConcurrentHttpsGets | .NET Core 2.0 | 228.03 ms | 1250.0000 | 312.5000 |
| ConcurrentHttpsGets | .NET Core 2.1 | 17.93 ms | 656.2500 | – |

That’s a 12.7x improvement in throughput and a huge reduction in garbage collections, even though the .NET Core 2.0 implementation has most of the logic in native rather than managed code! Similarly, on an 8-core Linux machine, here are my results:

| Method | Toolchain | Mean | Gen 0 | Gen 1 |
| --- | --- | --- | --- | --- |
| ConcurrentHttpsGets | .NET Core 2.0 | 135.46 ms | 750.0000 | 250.0000 |
| ConcurrentHttpsGets | .NET Core 2.1 | 21.83 ms | 343.7500 | – |

Again, huge improvement!

## [](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1/#and-more)And More

Through this post I aimed to categorize and group various performance changes to highlight areas of concentrated improvement, but I also want to highlight that performance work has happened across the breadth of runtime and libraries, beyond this limited categorization. I’ve picked a few other examples to highlight some of the changes to elsewhere in the libraries throughout the stack.

One particularly nice set of improvements came to file system enumeration support, in PRs [dotnet/corefx#26806](https://github.com/dotnet/corefx/pull/26806) and [dotnet/corefx#25426](https://github.com/dotnet/corefx/pull/25426). This work has made enumerating directories and files not only faster but also with significantly less garbage left in its wake. Here’s an example enumerating all of the files in my [System.IO.FileSystem library folder](https://github.com/dotnet/corefx/tree/master/src/System.IO.FileSystem) from my corefx repo clone (obviously if you try this one out locally, you’ll need to update the path to whatever works on your machine):

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_EnumerateFiles.cs"><tbody><tr><td id="file-perfblog04162018_enumeratefiles-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_enumeratefiles-cs-LC1"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_enumeratefiles-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_enumeratefiles-cs-LC2"><span>public</span> <span>void</span> <span>EnumerateFiles</span><span>(</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_enumeratefiles-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_enumeratefiles-cs-LC3"><span>{</span></td></tr><tr><td id="file-perfblog04162018_enumeratefiles-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_enumeratefiles-cs-LC4"><span>foreach</span> <span>(</span><span>string</span> <span>path</span> <span>in</span> <span>Directory</span><span>.</span><span>EnumerateFiles</span><span>(</span><span>@"d:\repos\corefx\src\System.IO.FileSystem\"</span><span>,</span> <span>"*.cs"</span><span>,</span> <span>SearchOption</span><span>.</span><span>AllDirectories</span><span>)</span><span>)</span></td></tr><tr><td id="file-perfblog04162018_enumeratefiles-cs-L5" data-line-number="5"></td><td id="file-perfblog04162018_enumeratefiles-cs-LC5"><span>{</span></td></tr><tr><td id="file-perfblog04162018_enumeratefiles-cs-L6" data-line-number="6"></td><td id="file-perfblog04162018_enumeratefiles-cs-LC6"><span>}</span></td></tr><tr><td id="file-perfblog04162018_enumeratefiles-cs-L7" data-line-number="7"></td><td id="file-perfblog04162018_enumeratefiles-cs-LC7"><span>}</span></td></tr></tbody></table>

The improvements are particularly stark on Windows, where this benchmark shows a 3x improvement in throughput and a 50% reduction in allocation:

| Method | Toolchain | Mean | Allocated |
| --- | --- | --- | --- |
| EnumerateFiles | .NET Core 2.0 | 1,982.6 us | 71.65 KB |
| EnumerateFiles | .NET Core 2.1 | 650.1 us | 35.24 KB |

but also on Unix, where this benchmark (with the path fixed up appropriately) on Linux shows a 15% improvement in throughput and a 45% reduction in allocation:

| Method | Toolchain | Mean | Allocated |
| --- | --- | --- | --- |
| EnumerateFiles | .NET Core 2.0 | 638.0 us | 56.09 KB |
| EnumerateFiles | .NET Core 2.1 | 539.5 us | 38.6 KB |

This change internally benefited from the `Span<T>`\-related work done throughout the framework, as did, for example, an improvement to `Rfc2898DeriveBytes` in `System.Security.Cryptography`. `Rfc2898DeriveBytes` computes cryptographic hash codes over and over as part of implementing password-based key derivation functionality. In previous releases, each iteration of that algorithm would result in at least one `byte[]` allocation, but now with `Span<T>`\-based methods like `HashAlgorithm.TryComputeHash`, due to PR [dotnet/corefx#23269](https://github.com/dotnet/corefx/pull/23269) those allocations are entirely avoided. And that results in dramatic savings, especially for longer iteration counts:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_DeriveBytes.cs"><tbody><tr><td id="file-perfblog04162018_derivebytes-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_derivebytes-cs-LC1"><span>private</span> <span><span>static</span></span> <span>readonly</span> <span>Rfc2898DeriveBytes</span> <span>s_db</span> <span>=</span> <span>new</span> <span>Rfc2898DeriveBytes</span><span>(</span><span>"verysafepassword"</span><span>,</span> <span>32</span><span>,</span> <span>10_000</span><span>,</span> <span>HashAlgorithmName</span><span>.</span><span>SHA256</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_derivebytes-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_derivebytes-cs-LC2"></td></tr><tr><td id="file-perfblog04162018_derivebytes-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_derivebytes-cs-LC3"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_derivebytes-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_derivebytes-cs-LC4"><span>public</span> <span>byte</span><span>[</span><span>]</span> <span>DeriveBytes</span><span>(</span><span>)</span> <span>=&gt;</span> <span>s_db</span><span>.</span><span>GetBytes</span><span>(</span><span>32</span><span>)</span><span>;</span></td></tr></tbody></table>

| Method | Toolchain | Mean | Allocated |
| --- | --- | --- | --- |
| DeriveBytes | .NET Core 2.0 | 9.199 ms | 1120120 B |
| DeriveBytes | .NET Core 2.1 | 8.084 ms | 176 B |

Effort has also been put into improving places where one platform is more deficient than others. For example, `Guid.NewGuid()` on Unix is considerably slower than it is on Windows. And while the gap hasn’t been entirely closed, as part of removing a dependency on the libuuid library, PR [dotnet/coreclr#16643](https://github.com/dotnet/coreclr/pull/16643) did significantly improve the throughput of `Guid.NewGuid()` on Unix:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_GuidNewGuid.cs"><tbody><tr><td id="file-perfblog04162018_guidnewguid-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_guidnewguid-cs-LC1"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_guidnewguid-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_guidnewguid-cs-LC2"><span>public</span> <span>void</span> <span>GuidNewGuid</span><span>(</span><span>)</span> <span>=&gt;</span> <span>Guid</span><span>.</span><span>NewGuid</span><span>(</span><span>)</span><span>;</span></td></tr></tbody></table>

| Method | Toolchain | Mean |
| --- | --- | --- |
| GuidNewGuid | .NET Core 2.0 | 7.179 us |
| GuidNewGuid | .NET Core 2.1 | 1.770 us |

The list goes on: improvements to array processing (e.g. [dotnet/coreclr#13962](https://github.com/dotnet/coreclr/pull/13962)), improvements to LINQ (e.g. [dotnet/corefx#23368](https://github.com/dotnet/corefx/pull/23368) from [@dnickless](https://github.com/dnickless)), improvements to `Environment` (e.g. [dotnet/coreclr#14502](https://github.com/dotnet/coreclr/pull/14502) from [@justinvp](https://github.com/justinvp)), improvements to collections (e.g. [dotnet/corefx#26087](https://github.com/dotnet/corefx/pull/26087) from [@gfoidl](https://github.com/gfoidl)), improvements to globalization (e.g. [dotnet/coreclr#17399](https://github.com/dotnet/coreclr/pull/17399)), improvements around pooling (e.g. [dotnet/coreclr#17078](https://github.com/dotnet/coreclr/pull/17078)), improvements to `SqlClient` (e.g. [dotnet/corefx#27758](https://github.com/dotnet/corefx/pull/27758)), improvements to `StreamWriter` and `StreamReader` (e.g. [dotnet/corefx#22147](https://github.com/dotnet/corefx/pull/22147)), and on.

Finally, all of the examples shown throughout this post were already at least as good in .NET Core 2.0 (if not significantly better) as in the .NET Framework 4.7, and then .NET Core 2.1 just made things even better. However, there are a few places where features were missing in .NET Core 2.0 and have been brought back in 2.1, including for performance. One notable such improvement is in `Regex`, where the `Regex.Compiled` option was exposed but ignored in .NET Core 2.0. PR [dotnet/corefx#24158](https://github.com/dotnet/corefx/pull/24158) brought back the in-memory compilation support for `Regex`, enabling the same kinds of throughput improvements here previously available in the .NET Framework:

<table data-hpc="" data-tab-size="4" data-paste-markdown-skip="" data-tagsearch-path="PerfBlog04162018_RegexCompiled.cs"><tbody><tr><td id="file-perfblog04162018_regexcompiled-cs-L1" data-line-number="1"></td><td id="file-perfblog04162018_regexcompiled-cs-LC1"><span>private</span> <span><span>static</span></span> <span>readonly</span> <span>Regex</span> <span>s_phoneNumberRegex</span> <span>=</span> <span>new</span> <span>Regex</span><span>(</span><span>@"^((\(\d{3}\) ?)|(\d{3}-))?\d{3}-\d{4}$"</span><span>,</span> <span>RegexOptions</span><span>.</span><span>Compiled</span><span>)</span><span>;</span></td></tr><tr><td id="file-perfblog04162018_regexcompiled-cs-L2" data-line-number="2"></td><td id="file-perfblog04162018_regexcompiled-cs-LC2"></td></tr><tr><td id="file-perfblog04162018_regexcompiled-cs-L3" data-line-number="3"></td><td id="file-perfblog04162018_regexcompiled-cs-LC3"><span>[</span><span>Benchmark</span><span>]</span></td></tr><tr><td id="file-perfblog04162018_regexcompiled-cs-L4" data-line-number="4"></td><td id="file-perfblog04162018_regexcompiled-cs-LC4"><span>public</span> <span>void</span> <span>RegexCompiled</span><span>(</span><span>)</span> <span>=&gt;</span> <span>s_phoneNumberRegex</span><span>.</span><span>IsMatch</span><span>(</span><span>"555-867-5309"</span><span>)</span><span>;</span></td></tr></tbody></table>

| Method | Toolchain | Mean |
| --- | --- | --- |
| RegexCompiled | .NET Core 2.0 | 473.7 ns |
| RegexCompiled | .NET Core 2.1 | 295.2 ns |

## [](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1/#whats-next)What’s Next?

Huge “thank you”s to everyone who has contributed to this release. As is obvious from this tour, there’s a lot to look forward to in .NET Core 2.1, and this post only scratched the surface of the improvements coming. We look forward to hearing your feedback and to your future contributions in the [coreclr](https://github.com/dotnet/coreclr), [corefx](https://github.com/dotnet/corefx), and other [dotnet](https://github.com/dotnet) and [ASP.NET](https://github.com/aspnet) repos!

## Author

![Stephen Toub - MSFT](https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2022/03/stoub_square-96x96.jpg)

Partner Software Engineer

Stephen Toub is a developer on the .NET team at Microsoft.